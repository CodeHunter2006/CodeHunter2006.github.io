---
layout: post
title:  "缓存穿透的解决方案——Bloom Filter"
date:   2019-01-23 10:00:00 +0800
tags: Redis Cache
---

# 什么是缓存穿透
为了提高热点数据的查询效率，我们将热点数据从Mysql数据库加载(预热)到Redis缓存中，以便快速查询。但是少数情况，在缓存中查询不到，还是要到数据库中查询，效率非常低。

这种情况如果能从数据库查询出还算好，但是如果是大量无效数据，每一个一定会去数据库找一圈，会导致查询性能急剧下降。这就是缓存穿透问题。

# 导致缓存穿透的原因
* 恶意攻击。通过程序寻找本来不存在的ID值，损耗服务性能。
* 未来的及预热就发生了查询。
* 本身是有效数据，但是是冷数据，不是热点数据，所以在缓存中不存在。

# 解决思路
* 识别热点数据，服务器启动时尽快预热，加载到Redis缓存中。
* 规范ID名，在前台进行正则过滤。
* 在后台有统一的查询和写入的入口，再次进行正则过滤，避免恶意攻击，前台没有过滤到。
* 进行是否存在的查询时，要进行同步操作，避免命中并加载到缓存中的ID在并发下引起数据库查询。
* 对一些无效ID，在缓存内保留，但是只保留ID而值为空，这样也可以防止热点错误ID导致的穿透。在这种情况下，要设定合理的有效时间，避免过多积累，导致内存被占满。另外要有根据内存情况的主动删除机制，避免恶意攻击导致的内存占满。
* 把所有ID都加载到内存里，放在HashTable中进行存在检测。但是这种需要容量较大，有更好的方案——布隆过滤器。

# 服务端增强方案 Bloom Filter(布隆过滤器)
布隆过滤器可以对较大数量的ID进行过滤，能够识别该ID在集合中是否 __一定没出现过__ 。

### 原理
![Bloom Filter](/assets/images/2019-01-23-Redis_CachePenetration_1.jpg)

布隆过滤器 = 一个bool类型的数组 + 多个不同的Hash函数

布隆过滤器使用过程：
* 首先要用集合的每个元素(x y z)执行所有Hash函数，在校验数组中留下自己对应的散列痕迹。
* 当一个未知的元素(a)需要校验时，同样执行所有Hash函数，然后判断每个函数的散列结果是否在数组中已存在。
* 如果所有散列点都存在，那么认为基本命中，可以进行跟深一步的校验(例如到Redis、Mysql进行查找)。
* 如果有某一个散列点不存在，那就说明这个元素在集合中不存在。

### 特点
* 建立校验数组过程比较慢，需要把所有集合中的元素对所有Hash函数执行一遍
* 这个创建过程不可逆，不可以删除集合元素
* 存在误判情况，存在一个误判率FP(碰撞率)
* 校验数组可能占用较大空间

### 设计点
增加数组容量、增加Hash函数种类都可以降低碰撞率，但是这之间要有权衡，如何达到最优化而不是盲目追求0碰撞率(那样就成了HashTable了)。
* 根据具体数据类型，选择合适的Hash函数，可以降低FP
* 根据自己的业务特点，只要将FP降低到一定程度，就可以满足需求

### 最佳实践
* 对于java，可以使用Google提供的guava包，里面提供了很好的布隆过滤器的实现，可以直接调节FP(错误率)。
* Go，可以使用[willf/bloom](https://github.com/willf/bloom)，其中FP的控制需要自己调节参数实现。

### 改进
布隆过滤器一般用于ID只增不减的情况，但是如果需要删除集合中的ID该怎么做呢？可以给bool数组绑定一个同样元素数量的用于计数的数组，根据情况，比如short型。

在生成校验数组同时，维护每一个校验位对应的次数统计。这样删除ID时，就可以在对应的计数数组中减1，如果减到0，则校验数组对应位置置0(false)。

显然的，这样会增加容量，但是特定业务可能需要这样做。








