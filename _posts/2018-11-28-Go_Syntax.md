---
layout: post
title: "Go使用中的一些特殊的语法点"
date: 2018-11-08 22:00:00 +0800
tags: Go
---

## 类型转换

- Go 的类型要求非常严格，类型转换必须显式执行。在 C++中一些常用的默认转换在 Go 中要注意转换

```
num := 0  // int型
num = int('9' - '0')  // 这里要将rune型显示转换为int
```

## const

Go 中无法定义常量数组

## string

### literal

- string 的字面表示一般用`"content"`，其中可以使用转移符如`"\n"`，用`"\u65e5"`表示 unicode 字符，用`"\xFF"`表示一个字节字符`0xFF=255`
- 也可以用'`'进行 raw 表示，可以跨行、会忽略其中的转义符

### range

- 对 string 进行 for range 可以得到每个字符的起始字节下标和字符 rune 值

```
for pos, char := range "你,好啊!" {
	// pos是字节下标、char是rune值
}
```

## 逻辑选择

### for

- for 循环中 break、continue 都可以加 label，直接跳转到某层 for(停止/继续)。跳转的目的 label 必须在某个 for 的外面，形成包围(enclosing)的形式。

```Go
OuterLoop:
	for i = 0; i < n; i++ {
		for j = 0; j < m; j++ {
			switch a[i][j] {
			case nil:
				state = Error
				break OuterLoop
			case item:
				state = Found
				break OuterLoop
			}
		}
	}
```

- for 与 range 结合时，注意临时对象在当作右值时不要传地址，否则很可能发生逻辑错误
- for 与 range 结合时，如果数组元素的类型是对象而不是指针，注意使用下标修改元素内容，否则只作用于临时对象，修改无效

### switch

Go 中 switch 的每个 case 后会自动添加 break，所以会独立执行。如果想要连续执行，可以使用 fallthrough 语句。

switch 中 每个 case 可以有多个或者关系的匹配项，用`,`隔开，如：

```Go
switch value {
	case 1, 2, 3:
	// xxx
	case 4:
	// xxx
}
```

- Go 中类型要求很严格，switch 比较时会同时比较类型，所以类型一定要完全匹配。

```Go
const caseValue1 = 20
obj := int64(20)
switch obj {
	case caseValue1:
	// 不会走这里
	default:
	// 会走这里，因为类型不完全匹配
}
```

```Go
for _, obj := range objectArray {
	// 这里将导致 leftArray 中的元素地址全部是临时对象地址
	leftArray = append(leftArray, &obj)
}
```

### select

select 相当于在线程阻塞方面的 switch，以往由操作系统提供，现在直接在语言层面实现

- select 其中的 case 可以是从 channel 读取也可以是向 chennel 写入，多个 case 之间如果同时可发生则随机选择一个
- 有 default 的情况下，并不会阻塞，没有会继续执行
- `select {}`表示永久阻塞
- select 会隐含自动使用 break 语句，所以在其中使用 break 语句会被 select"吸收"而不会传到到外层的 for 循环，需要用 break label 解决

### label

label 声明后可用于`goto/break/continue`语句后边

- goto 语句后边表示当前执行跳转到指定行
- label 用于 break 和 continue 表示 break、continue 所作用的逻辑循环`for/switch/select`，所以 label 声明所在位置应在想起作用的循环范围外

```Go
loop:
	for {
		for {
			break loop
		}
	}
```

## channel

- len()、cap()作用于 chan 时，可以取得已经缓存的消息数量和 buffer 容量。

- 使用 range 语法取出 chan 的值时可以自动监听 close 状态并退出循环

```Go
for x := range ch {
	// use x
}
// ch is closed
```

## 短声明符号`:=`

- := 短声明符号，(非 if/for 声明位置)在左边的变量已经存在的情况下，会做一些兼容操作：
  - 如果左边的多个变量中有没声名的也有已声明的，那么对已经声明的只做赋值运算
  - 如果变量都已经在外部作用域声明，那么会创建一个新的变量
  - 如果变量都是当前作用域已声明的，会报错，要求使用 `=` 符号

* **注意**对于 if 和 for 语句开头的短声明，所有外部变量都会被覆盖为新变量，这种被覆盖的变量编译器难以察觉，叫做"阴影中的变量"(shadowing variable)。
  可以用下面工具检测代码中是否存在 shadowing variable。

```shell
# 安装 go-nyet
go get github.com/barakmich/go-nyet
go-nyet ./...		# 扫描当前文件夹下所有文件
go-nyet package		# 扫描指定包
go-nyet main.go		# 扫描指定文件
# 返回结果：main.go:10:3:Shadowing variable `x`
```

## slice

slice 对象有三个字段：数组指针、length、capacity。

- 通过一个 slice 可以创建一个新的 slice`sl2 := sl1[1:2]`，那么两个 slice 的数组指针指向同一个数组
- 此时如果通过下标赋值，两个 slice 可以相互影响
- 如果新的 slice 不断 append 导致数组重新申请，则数组指针会指向不同数组
- 所以在使用 slice 作为参数时，不能指望通过副作用改变原有 slice。可以直接返回新 slice 或传入`*[]int`
- slice 扩容过程：在 1024 个元素之前，每次扩容翻倍；在 1024 个元素后，每次以 1.25 倍扩容

```Go
s1 := []int{0,1,2,3,4,5}
s2 := s1[1:3]	// {1, 2} = [1,3) 取左闭右开区间
```

- 用 append 给数组或 slice 添加元素：`sli = append(sli, element)`，添加整个 slice 的元素时`sli = append(sli, sli1...)`

- 数组清空时，可以用`a = a[:0]`，这样可以复用原有空间实现清空

- 可以创建多维数组或 slice

```Go
threeDSlice := [][][]int{{{1}}}
```

- slice 的值为 nil 是有效的，一般要用`len(sli)`来判断切片是否为空，不要用`sli == nil`。
- slice 为 nil 时，有可能是 len 为 0 的 slice 已经创建好了，也可能是没有创建好
- map[string][]string，对未初始化的 Key 读取时，取得的是真的 nil，进行赋值动作时，会自动创建 len 为 0 的 slice

```Go
testSli := []int{2:2, 3, 0:7, 8}
```

- 用字面值初始化 slice 时，可以指定下标
- 如果中间有没有指定下标的元素，下标是前面元素下标+1

```Go
sli1 := make([]int, 5, 10)	// make 返回被初始化好的 slice，len 为 5， cap 为 10
sli2 := new([2]int)	// new 创建一个 len 为 2，cap 为 2 的 slice 的指针
```

## 可变参数

函数的最后一个参数可以是可变参数类型，其本质是一个特定类型的 slice

```Go
func appendInt(x []int, y ...int) {
	// y can be used as []int type
}
a, b, c []int
b = appendInt(a, 1, 2, 3)
c = appendInt(a, b...)
```

## const

- 利用 iota 可以方便的定义枚举常量

```
type ByteSize float64

const (
    _  = iota                      // ignore first value by assigning to blank identifier
    KB ByteSize = 1 << (10 * iota) // 1 << (10*1)
    MB                             // 1 << (10*2)
    GB                             // 1 << (10*3)
    TB                             // 1 << (10*4)
    PB                             // 1 << (10*5)
    EB                             // 1 << (10*6)
    ZB                             // 1 << (10*7)
    YB                             // 1 << (10*8)
)
```

## Receiver

- 对象类型的 Receiver 意味着按照拷贝传值，所以 Method 调用后可能不会修改对象本身

```Go
type Test struct {
	A int
}
func (t Test) Change() {
	t.A = 5
}

test := Test{}
fmt.Printf("%v", test.A)	// 0
test.Change()
fmt.Printf("%v", test.A)	// 实际是 0，并不是 5
```

## interface

`interface`是 Go 中特有的数据类型，它由两部分组成：类型+数据，用法类似 C++中的对象指针，可以由父类指针指向子类对象。

![MySQL structure](/assets/images/2018-11-28-Go_Syntax_interface_1.jpg)

- interface 在底层有两种可能的数据结构 eface(empty interface) 和 iface，其中 eface 表示`interface{}`，iface 表示至少带有一个函数的 interface，由编译器决定使用哪种数据类型
- \_type 指针指向实际类型描述
- data 表示数据指针
- tab 指向 itab 结构

![MySQL structure](/assets/images/2018-11-28-Go_Syntax_interface_2.jpg)

- 如果实际类型是一个值，interface 会在堆上为这个值分配一块内存、复制，然后用 data 指向它
- 如果实际类型是一个指针，那么 interface 会把指针的值(也就是对象的地址)保存在 data

![MySQL structure](/assets/images/2018-11-28-Go_Syntax_interface_3.jpg)
itab 表示 interface 和 实际类型的转换信息。对于每个 interface 和实际类型，只要在代码中存在引用关系， go 就会在运行时为这一对具体的 `<Interface, Type>` 生成 itab 信息。

- inter 指向对应的 interface 的类型信息
- type 和 eface 中的一样，指向的是实际类型的描述信息 \_type
- fun 为函数列表，表示对于该特定的实际类型而言，interface 中所有函数的地址
- 由于 fun 是运行时生成的，所以假设 interface 有 m 个函数、struct 有 n 个函数，那么构建过程的双重遍历时间复杂度为 O(m\*n)。由于编译器在编译期对函数名进行了排序，所以实际时间复杂度是 O(m+n)

### interface 特性

- interface 变量之间比较时，type、data 都相等时才相等
- interface 变量间赋值时，如果源 interface 是用指针初始化的，则两个 interface 等价；如果源 interface 是用对象初始化的，则 data 字段会发生拷贝，所以无法完全等价

### interface 强转

- 可以用`value, ok = i.(int)`尝试强制转换，如果转换失败则`ok == false`、`value`为默认值
- 可以直接用`i.(int) == 5`这种形式转为目标类型，这里没有转换错误判断，所以一旦类型错误将抛出 panic

## init

在包中可以添加`init`函数，用于对包环境进行初始化。利用`import _ "xxx/xxx"`语句可以强制导入包进行初始化，但不调用。

## type

- 重新类型声明不会继承原类型的函数，如果想继承成员的同时继承函数，可以使用"匿名嵌入"

```golang
type myMutex sync.Mutex
func main() {
    var mtx myMutex
    mtx.Lock()	// mtx.Lock undefined
}
```

## 数字的字面表示前缀(number literal prefixes)

Go 1.13 增加了一些常用的不同进制字面表示方法：

```
// 0b 或 0B 表示二进制
0b0101

// 0 或 0o 表示8进制
0o720

// 0x 或 0X 表示16进制

```

## `^`符号的两个用法

- 通常`^`表示`按位异或`运算
- 在 Golang 中，如果作为一元运算符出现，表示`按位取反`。(在其他语言中通常以`~`表示)

## `&^`按位清零运算符

这种运算可以用于将组合标志位变量的某个标志位清零。

```
// 下面以单个位来演示
0 &^ 0 => 0
1 &^ 0 => 1
0 &^ 1 => 0
1 &^ 1 => 0
// 右边为1时，会将左边的操作数清零；
// 右边为0时，不处理。

x := 0b1111 // 111
x = x &^ (1 << 1)   // x => 0b1101
```

## 用`==`比较数组/struct

- 相同类型、元素数量一致的数组才能比较
- 每个元素用`==`比较都相同时结果才是 true
- struct 也可以比较，只要其中的成员都是可比较的就可以
- 虽然 struct 中的成员是可比较的，但是一定要搞清有哪些类型的成员。比如 time.Time 有专门的 Equals 比较函数，这时用 == 比较时就可能出错。

参考：<br/>
[http://docs.golang.com/doc/effective_go.html](http://docs.golang.com/doc/effective_go.html)

## container

### map

- 未初始化(make)的 map 是一个 nil map，可以进行读取、range 遍历、delete、len 等只读操作，但是如果执行写入动作则会引起 panic。
- map 没有 clear 函数，可以直接重新 make 一个；Go 1.11 版本后，遍历 map 并 delete 所有元素的代码会被自动编译为了内置函数 mapclear 效率很高。
- 遍历 map 时，顺序是随机的。原本 map 在自动扩容前顺序是固定的，但是设计者为了避免调用者依赖这种脆弱的固定性，故意增加了随机性。
- map 创建时可以指定容量，但由于 map 的本质是 hash，所以无法通过 cap 获得容量值，cap 时会返回 error。
- 对于 key 类型较简单的情况，引用一个不存在的 key 的 value 会得到一个默认值，这与 C++容器的用法一致
- 在遍历 map 过程中，可以 delete 当前元素，是安全的，并且可以正确删除

### set

Go 中可以用这种方式实现 Set:

```Go
m1 := make(map[string]struct{})
m2 := map[string]struct{} {
	"a": struct{}{},
	"b": {}	// 与 struct{}{} 等价
}
```

这样 Value 占用的空间为 0

- `struct{}`表示存储空间为 0 的一种类型
- `struct{}{}`表示构造一个这种占用空间为 0 的对象，可以简写为`{}`
- 其实在 Go 进程中全局只有一个这个类型的对象，这些对象应该只占用一个共通的空间，所以实例占用空间为 0

### defer

- defer 在函数返回时开始执行，执行发生在 return 语句之后。
- 多个 defer 以栈的形式执行，先进后出(先 defer 后被执行)
- defer 对应的函数调用参数的值，是在 defer 语句时就决定的。而函数中捕获的变量是后来运行时决定的。
- 如果函数中调用 os.Exit(0) 这种方式退出程序，则 defer 将不被执行，因为没有按调用栈返回到 main 函数。

## function

### 函数变量

函数是 Go 语言的"一等公民"，也是一种类型，所以可以定义一个函数变量，用来指向一个函数的实现，相当于 C++中的函数指针。

### anonymous function(匿名函数)

在 Golang 函数中，可以随时定义匿名函数。

- 匿名函数的内部会形成闭包(Closure)结构，将其中用到的外部变量引用保留下来以备未来使用。
- 匿名函数可以直接赋值给一个函数类型的变量，以后通过这个变量调用，这样匿名函数就变成了有名函数。

匿名函数递归：

```Go
func test() {
	reFunc := func(i int) {
		if i > 0 {
			fmt.Println(i)
			return reFunc(i - 1)
		}
		return
	}
}
```

上面的代码编译报错："reFunc not declared"。
由于`:=`右边要先编译出来再赋值给左边，所以`reFunc`在右边函数定义中是未定义的。
可以用下面的函数变量(相当于 C++函数指针)的方法实现:

```Go
func test() {
	var reFunc func(int)	// 提前定义变量
	reFunc = func(i int) {
		if i > 0 {
			fmt.Println(i)
			return reFunc(i - 1)
		}
		return
	}
}
```
