---
layout: post
title: "Go使用中的一些特殊的语法点"
date: 2018-11-08 22:00:00 +0800
tags: Go
---

## 类型转换

- Go 的类型要求非常严格，类型转换必须显式执行。在 C++中一些常用的默认转换在 Go 中要注意转换

```
num := 0  // int型
num = int('9' - '0')  // 这里要将rune型显示转换为int
```

## const

Go 中无法定义常量数组

## string

- 对 string 进行 for range 可以得到每个字符的起始字节下标和字符 rune 值

```
for pos, char := range "你,好啊!" {
	// pos是字节下标、char是rune值
}
```

## 逻辑选择

### for

- for 循环中 break、continue 都可以加 label，直接跳转到某层 for(停止/继续)。跳转的目的 label 必须在某个 for 的外面，形成包围(enclosing)的形式。

```Go
OuterLoop:
	for i = 0; i < n; i++ {
		for j = 0; j < m; j++ {
			switch a[i][j] {
			case nil:
				state = Error
				break OuterLoop
			case item:
				state = Found
				break OuterLoop
			}
		}
	}
```

- for 与 range 结合时，注意临时对象在当作右值时不要传地址，否则很可能发生逻辑错误

### switch

Go 中 switch 的每个 case 后会自动添加 break，所以会独立执行。如果想要连续执行，可以使用 fallthrough 语句。

switch 中 每个 case 可以有多个或者关系的匹配项，用`,`隔开，如：

```Go
switch value {
	case 1, 2, 3:
	// xxx
	case 4:
	// xxx
}
```

- Go 中类型要求很严格，switch 比较时会同时比较类型，所以类型一定要完全匹配。

```Go
const caseValue1 = 20
obj := int64(20)
switch obj {
	case caseValue1:
	// 不会走这里
	default:
	// 会走这里，因为类型不完全匹配
}
```

```Go
for _, obj := range objectArray {
	// 这里将导致 leftArray 中的元素地址全部是临时对象地址
	leftArray = append(leftArray, &obj)
}
```

- len()、cap()作用于 chan 时，可以取得已经缓存的消息数量和 buffer 容量。

## 短声明符号`:=`

- := 短声明符号，在左边的变量已经存在的情况下，会做一些兼容操作：
  _ 如果左边的多个变量中有没声名的也有声明的，那么对已经声明的只做赋值运算
  _ 如果变量已经在外部作用域声明，那么会创建一个新的变量 \* 如果变量都是当前作用域已声明的，会报错，要求使用 `=` 符号

## slice

- 用 append 给数组或 slice 添加元素：`sli = append(sli, element)`，添加整个 slice 的元素时`sli = append(sli, sli1...)`

- 数组清空时，可以用`a = a[:0]`，这样可以复用原有空间实现清空

- 可以创建多维数组或 slice

```
// 使用中要去除多余的'\'
threeDSlice := [][][]int\{\{\{1\}\}\}
```

- slice 的值为 nil 是有效的，一般要用`len(sli)`来判断切片是否为空，不要用`sli == nil`。
- slice 为 nil 时，有可能是 len 为 0 的 slice 已经创建好了，也可能是没有创建好
- map[string][]string，对未初始化的 Key 读取时，取得的是真的 nil，进行赋值动作时，会自动创建 len 为 0 的 slice

## const

- 利用 iota 可以方便的定义枚举常量

```
type ByteSize float64

const (
    _  = iota                      // ignore first value by assigning to blank identifier
    KB ByteSize = 1 << (10 * iota) // 1 << (10*1)
    MB                             // 1 << (10*2)
    GB                             // 1 << (10*3)
    TB                             // 1 << (10*4)
    PB                             // 1 << (10*5)
    EB                             // 1 << (10*6)
    ZB                             // 1 << (10*7)
    YB                             // 1 << (10*8)
)
```

## interface{}

`interface{}`是 Go 中特有的数据类型，它由两部分组成：类型+数据，用法类似 C++中的对象指针，可以由父类指针指向子类对象。

- 在包中可以添加`init`函数，用于对包环境进行初始化。利用`import _ "xxx/xxx"`语句可以强制导入包进行初始化，但不调用。

## 数字的字面表示前缀(number literal prefixes)

Go 1.13 增加了一些常用的不同进制字面表示方法：

```
// 0b 或 0B 表示二进制
0b0101

// 0 或 0o 表示8进制
0o720

// 0x 或 0X 表示16进制

```

## `&^`按位清零运算符

这种运算可以用于将组合标志位变量的某个标志位清零。

```
// 下面以单个位来演示
0 &^ 0 => 0
1 &^ 0 => 1
0 &^ 1 => 0
1 &^ 1 => 0
// 右边为1时，会将左边的操作数清零；
// 右边为0时，不处理。

x := 0b1111 // 111
x = x &^ (1 << 1)   // x => 0b1101
```

## 用`==`比较数组/struct

- 相同类型、元素数量一致的数组才能比较
- 每个元素用`==`比较都相同时结果才是 true
- struct 也可以比较，只要其中的成员都是可比较的就可以
- 虽然 struct 中的成员是可比较的，但是一定要搞清有哪些类型的成员。比如 time.Time 有专门的 Equals 比较函数，这时用 == 比较时就可能出错。

参考：<br/>
[http://docs.golang.com/doc/effective_go.html](http://docs.golang.com/doc/effective_go.html)

## container

### map

map 没有 clear 函数，可以直接重新 make 一个

### set

Go 中可以用这种方式实现 Set:

```Go
m1 := make(map[string]struct{})
m2 := map[string]struct{} {
	"a": struct{}{},
	"b": struct{}{}
}
```

这样 Value 占用的空间为 0

- `struct{}`表示存储空间为 0 的一种类型
- `struct{}{}`表示构造一个这种占用空间为 0 的对象
- 其实在 Go 进程中全局只有一个这个类型的对象，这些对象应该只占用一个共通的空间，所以实例占用空间为 0
