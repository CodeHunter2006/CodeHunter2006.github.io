---
layout: post
title: "Lock"
date: 2021-01-22 22:00:00 +0800
tags: HighConcurrency
---

<img src="/assets/images/2021-01-23-Lock_1.jpeg" alt="Lock" width="350"/>

记录一些编程中**锁**相关的名词解释

## 为什么需要锁？

多个线程使用同一个资源时，加锁保证原子性。如果不加锁可能导致逻辑(一致性)问题，也就是线程安全问题。

- 常见的加锁场景：

  - 单 CPU、多线程、一系列操作需要原子执行。如果不加锁，原子操作中的变量可能中途被改变。在多 CPU 下更需要加锁。
  - 多 CPU、多线程、小容量变量的变更。
    由于每个 CPU 有自己的多级缓冲、寄存器，一个最基本的操作可能被拆分为多部执行，
    比如`x++ <=> x = x+1`，这就无法保证逻辑一致性。
    小容量变量都加锁，大容量变量如结构体或多个变量就更应该加锁了。

- 下面两种特殊情况可以不加锁：

  - 如果小容量值(例如 32 位 CPU 下的 int32)的修改、单 CPU 情况下，可以不加锁。
    因为这种情况真实运行的线程只能有一个，并且小容量变量的修改是原子性的，不会有线程安全问题。
  - 如果是单 CPU、变量前用 volatile 修饰的，变量整体赋值，可以不加锁。volatile 关键字确保编译时不优化。

- 为什么读数据也需要锁？
  通常数据都不能正好一个 CPU 周期内读取，比如一个 32 位的 CPU 读取 int64 时就需要两步 32 位的操作实现，这时中间如果被修改了，就可能脏读。
  而往往我们保存的数据要远远大于 32 位，比如一个结构体对象，所以也要读锁保证原子性。

## 死锁

多个线程对不同资源加锁，进入并保持相互等待的状态。

### 发生条件

1. 加锁顺序不一致
2. 各自占有部分锁不释放

### 应对方案

针对上面发生的条件，只要打破条件就能避免死锁

- 所有线程获得资源时，保持一致的加锁顺序。这样前面资源未获得的也不会对后面资源加锁
- 一次获得所有资源的总锁，然后执行。简单粗暴，可以避免死锁，但并发性差
- 占有锁后，如果无法获得别的锁，则超时释放资源、稍后再试。类似乐观锁逻辑

### 分析方法

一般会有工具，可以列出发生死锁时的线程和资源锁状况，知道哪些线程获得了哪些锁、哪些线程在等待哪些锁，
这样就可以画出一个依赖关系图。而关系图中出现了循环，说明发生了死锁。只要打破循环就能解锁。

## 常用锁结构

### Mutex(互斥锁)

### RWLock(读写锁)

### 分布式锁

## 使用模式

### 悲观锁

### 乐观锁

## 锁特性

### 可重入锁

## 数据库

### 范围

行锁、表锁、间隙锁、临键锁

### 操作目的

读锁、写锁、意向锁(意向读、意向写)
