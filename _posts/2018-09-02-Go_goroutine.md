---
layout: post
title:  "goroutine的GPM模型"
date:   2018-09-02 10:11:00 +0800
tags: Go
---
goroutine是Go最核心的特性。为什么它可以比多线程效率更高？底层的实现机制是怎样的？

# 进程、线程对CPU利用的瓶颈 —— 用户态内核态切换
进程是资源的单位，与其它进程相隔离，有独立的IO、堆、栈，多个进程之间受操作系统调度。

线程是真正执行的单位，在同一个进程中多个线程共享文件、堆等进程资源，但是有独立的栈。在多CPU硬件下，每个CPU可以运行一个线程，如果存在多个线程，则由系统负责调度。

![](/assets/images/2018-09-02-Go_goroutine_2.png)
对于任何一个进程，都有两个栈，一个用户态栈、一个内核态栈，其中用户态栈是我们的代码运行的空间，但是只凭我们的代码很多操作无法执行。

操作系统内核为我们提供了存储、IO、硬件中断、软中断等功能。当我们进行系统调用时，就会进行用户态和内核态的切换。这个切换过程主要是对用户态的寄存器进行保存，另外由于内核态的CPU权限较高也会进行额外的安全检查。在内核态执行完毕后，再进行切换，转为用户态。

上面的切换过程，就会导致CPU效率的下降。另外，由于系统调度，运行了一段时间的线程会被主动切换成另一线程，这个过程并没有增加总的CPU使用率，反而降低了总效率，只是看起来单个线程没有死掉。

# 协程的改进点
在线程进行耗时操作时(如IO操作)，就会发生上下文切换，当前线程被挂起。等待IO操作返回后，当前线程进入Ready状态等待调度启动。

协程是在线程基础上实现的，也面临相同的问题，在进行IO、channel等耗时操作时，也需要进行状态切换进入等待状态。但是为了避免发生用户态和内核态的耗时切换，在Go的Runtime支持下，goroutine可以主动放弃当前的线程占用给gorutine调度器，同时进入IO返回等待状态，等返回之后，再进入队列等待调度。

由于这种主动的切换寄存器、缓存的context的容量成本非常低，goroutine是4K而线程大于1M（200多倍），所以切换损耗特别小，能够充分的利用CPU。

# 服务器的常见实现方式(Go协程的演化)
### 多线程(进程)阻塞IO
为每一个用户的连接创建一个线程，或使用线程池避免创建和销毁线程的开销。线程中进行网络IO操作时会发生阻塞，这时候线程A会切换进入内核态、线程B被内核态唤醒切换进入用户态然后执行、接着又可能发生阻塞切换...

这种方式的优点是逻辑简单，在线程函数内只要按照业务逻辑顺序考虑就可以。典型的就是Tomcat服务器，QPS只能达到千级。

在并发量不大的情况下，这种由于IO阻塞引发的切换损耗并不明显。但是在高并发情况下，CPU由于不断切换，性能会急剧下降。所以要想实现高并发，必须用无阻塞的方式实现。

### 单线程非阻塞IO
使用单线程处理所有用户连接，对IO进行非阻塞的访问(如果无数据则立刻返回)。每个用户的不同阶段要注册对应的回调函数，在该用户的IO有数据的情况下就调用回调函数处理，然后再等待其他IO有数据的时候进行回调。

由于不存在阻塞，所以执行效率特别高。只有在所有IO都没有数据的情况下才会利用epoll进行等待，而这个效率也是很高的。这种方式可以应对较大的并发，典型的服务器有Nginx、Redis、Libevent库，QPS能达到10万级。

但是这种方式有两个缺点：1.没有充分利用所有CPU。2.逻辑较复杂，由回调函数和状态切换组成。

### 单线程协程
其实协程的概念很早就被提出，也有过很多实现，就是为了解决单线程非阻塞IO的逻辑复杂问题。

其实在上面的方案中对于每一个用户的请求，可以仍然使用一个函数执行，但是需要一个额外的数据结构保存函数运行的上下文(栈、寄存器)，然后根据IO情况进行主动的切换调度，就可以同时满足非阻塞、高并发、逻辑简单。

但是这些协程实现普遍只利用了一个CPU，没有充分利用资源。如果要利用多CPU，需要自己启动多个进程进行协调。

# Go的GPM模型
![](/assets/images/2018-09-02-Go_goroutine.png)
Go的GPM模型，其实就是单线程协程的改进版，可以同时利用多个CPU实现协程调度。这样同时具有了CPU密集和IO密集的运算能力，同时逻辑实现也简单。

__G(Goroutine)__ 是应用层代码开启的goroutine

__M(Machine)__ 是Go Runtime自动开启的线程，具体数量取决于CPU核数和goroutine数量，实际数量往往要多于CPU数量，多个M构成线程池

__P(Process)__ 是M上调度G运行的一个中间层，是CPU的抽象，所以一般P的数量与CPU核数一致，可以调用runtime.GOMAXPROCS(num)执行，程序运行后不再改变

最上面有一个总的队列，用户启动的G都是从这里入队。在每一个P上，对应着一个G的队列。

M是真正的执行线程，P在执行时会唤醒一个M，然后拿所属的一个G来执行。

在遇到等待时(IO无数据)，M对应的上下文（栈、寄存器SP、PC等）会保存到G。如果此时G没有执行完，会被重新放到P的任务队列中等待下次被调度，然后通过P寻找其他可执行的G，通过G中保存的数据恢复上下文然后继续执行。

如果M被阻塞，P会与M分离(handoffp)，G继续与M绑定。P会去唤醒其他的M继续执行其他的G。等M阻塞结束后，绑定的G会被重新放入总队列。这种情况会发生用户态内核态切换，并且可能要创建新的线程，所以代价也会较大。在使用时应考虑到，避免大量并发阻塞导致线程数暴增。
* 不会阻塞M的操作：
	* 网络IO
	* 锁
	* channel
	* time.sleep
	* 基于底层系统异步调用的Syscall
* 会阻塞M的操作：
	* 本地IO调用
	* 基于底层系统同步调用的Syscall
	* CGo方式调用C语言动态库中的调用IO或其它阻塞

# 一些设计点
* 以前版本的模型中是没有P的，垂直队列直接与M绑定。这样的缺点是如果M上运行的G阻塞了，那么后边的G都要等待，虽然存在"偷取"机制，但是还是会浪费一些时间。

* 当goroutine较多时，Runtime会创建很多线程。当这些G执行完毕后，线程仍然不会释放，等待以后的执行。

* 当P对应的队列处理完后，就会从总队列取G。如果总队列没有，则会去其他的P对应的队列中"偷取"，一般会偷一半过来执行。这样避免出现线程空闲。

* 在有些情况下，程序段会一直占用CPU而不进入内核调用(纯计算)，会导致G一直占用CPU，妨碍了调度。可以主动添加`runtime.Gosched()`增加调度机会。

<br/>
PS:<br/>
协程并不是Go的专属，Lua等语言都实现了协程，golang team成员之一的Russ cox在加入golang team之前用C实现过协程。<br/>
[源码](https://swtch.com/libtask/)，[中文注释版本](https://www.cnblogs.com/foxmailed/p/3509359.html)

(转)[漫画：什么是协程？](https://www.sohu.com/a/236536167_684445)

(转)[C语言实现协程](https://blog.csdn.net/xiaobing1994/article/details/79024972?from=singlemessage)