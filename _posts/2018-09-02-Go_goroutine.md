---
layout: post
title:  "goroutine的GPM模型"
date:   2018-09-02 10:11:00 +0800
tags: Go
---
goroutine是Go最核心的特性。为什么它可以比多线程效率更高？底层的实现机制是怎样的？

# 进程、线程对CPU利用的瓶颈 —— 用户态内核态切换
进程是资源的单位，与其它进程相隔离，有独立的IO、堆、栈，多个进程之间受操作系统调度。

线程是真正执行的单位，在同一个进程中多个线程共享文件、堆等进程资源，但是有独立的栈。在多CPU硬件下，每个CPU可以运行一个线程，如果存在多个线程，则由系统负责调度。

![](/assets/images/2018-09-02-Go_goroutine_2.png)
对于任何一个进程，都有两个栈，一个用户态栈、一个内核态栈，其中用户态栈是我们的代码运行的空间，但是只凭我们的代码很多操作无法执行。

操作系统内核为我们提供了存储、IO、硬件中断、软中断等功能。当我们进行系统调用时，就会进行用户态和内核态的切换。这个切换过程主要是对用户态的寄存器进行保存，另外由于内核态的CPU权限较高也会进行额外的安全检查。在内核态执行完毕后，再进行切换，转为用户态。

上面的切换过程，就会导致CPU效率的下降。另外，由于系统调度，运行了一段时间的线程会被主动切换成另一线程，这个过程并没有增加总的CPU使用率，反而降低了总效率，只是看起来单个线程没有死掉。

# 协程的改进点
在线程进行耗时操作时(如IO操作)，就会发生上下文切换，当前线程被挂起。等待IO操作返回后，当前线程进入Ready状态等待调度启动。

协程是在线程基础上实现的，也面临相同的问题，在进行IO、channel等耗时操作时，也需要进行状态切换进入等待状态。但是为了避免发生用户态和内核态的耗时切换，在Go的Runtime支持下，goroutine可以主动放弃当前的线程占用给gorutine调度器，同时进入IO返回等待状态，等返回之后，再进入队列等待调度。

由于这种主动的切换寄存器、缓存的context的容量成本非常低，goroutine是4K而线程大于1M（200多倍），所以切换损耗特别小，能够充分的利用CPU。

# Go的GPM模型
![](/assets/images/2018-09-02-Go_goroutine.png)

__G__ 是应用层代码开启的goroutine

__M__ 是Go Runtime自动开启的线程，具体数量取决于CPU核数和goroutine数量，实际数量往往要多于CPU数量，多个M构成线程池

__P__ 是M上调度G运行的一个中间层，是CPU的抽象，所以一般P的数量与CPU核数一致，可以调用runtime.GOMAXPROCS(num)执行，程序运行后不再改变

最上面有一个总的队列，用户启动的G、耗时操作后返回的G都是从这里入队。在每一个P上，对应着一个G的队列。G在运行时要绑定一个P，由P绑定一个M进行运行。

当G在一个M上阻塞时，P与M分离，P继续与其他的M结合，G与M继续绑定阻塞，直到返回后重新进入队列。

# 一些设计点
* 以前版本的模型中是没有P的，垂直队列直接与M绑定。这样的缺点是如果M上运行的G阻塞了，那么后边的G都要等待，虽然存在"偷取"机制，但是还是会浪费一些时间。

* 当goroutine较多时，Runtime会创建很多线程。当这些G执行完毕后，线程仍然不会释放，等待以后的执行。

* 当P对应的队列处理完后，就会从总队列取G。如果总队列没有，则会去其他的P对应的队列中"偷取"，一般会偷一半过来执行。这样避免出现线程空闲。

<br/>
PS:<br/>
协程并不是Go的专属，Lua等语言都实现了协程，golang team成员之一的Russ cox在加入golang team之前用C实现过协程。<br/>
[源码](https://swtch.com/libtask/)，[中文注释版本](https://www.cnblogs.com/foxmailed/p/3509359.html)

(转)[漫画：什么是协程？](https://www.sohu.com/a/236536167_684445)
