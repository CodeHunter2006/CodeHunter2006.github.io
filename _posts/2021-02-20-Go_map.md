---
layout: post
title: "Go map sync.Map"
date: 2021-02-20 22:00:00 +0800
tags: Go
---

# map

![map](/assets/images/2021-02-20-Go_map_1.jpg)

hmap 结构体

```Go
type hmap struct {
  count	int       // 当前保存元素个数
  B	    uint8     // 创建桶的个数为 2 的 B 次方
  flags           // 并发操作标志
  hash0           // hash 因子，用于生成 hash 值
  buckets	unsafe.Pointer // bucket数组指针，数组的大小为2^B
}
```

bmap 结构体

```Go
type bmap struct {
  tophash	  [8]uint8	// 存储哈希值的高8位
  data	    byte[1]	  // key value数据：key/key/key/.../value/value/value...
  overflow	*bmap	    // 溢出 bucket 地址（拉链法）
}
```

- 倍增扩容

  - 负载因子 6.5，当`count/(2^B) > 6.5`则翻倍扩容
  - 倍增扩容时，遍历旧桶元素，重新分配到新桶的低或高位，使用`B+1`位区分
  - 扩容过程，分别记录旧桶、新桶、当前扩容桶序号。
    然后在每次 map 操作时检查当前是否为扩容中，如果在扩容中，则每次处理一个旧桶，直到扩容结束。
    扩容过程新值写入新桶中

- 等量扩容

  - 如果`B<15 && 溢出桶数量>常规桶数量`或`B>=15 && 溢出桶数量 > 2^15`则触发等量扩容
  - 往往等量扩容时没有达到负载因子而溢出桶数量很大，这种情况是因为溢出桶中被删除了很多元素导致排列不紧密。
    重新等量扩容，有助于将桶内元素重新紧凑排列。

- 线程安全：

```Go
var counter = struct{
    sync.RWMutex
    m map[string]int
}{m: make(map[string]int)}
```

# sync.Map

1. 空间换时间。通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。
2. 使用只读数据(read)，避免读写冲突。
3. 动态调整，miss 次数多了之后，将 dirty 数据提升为 read。
4. double-checking。
5. 延迟删除。删除一个键值只是打标记，只有在提升 dirty 的时候才清理删除的数据。
6. 优先从 read 读取、更新、删除，因为对 read 的读取不需要锁。
