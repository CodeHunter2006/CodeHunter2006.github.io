---
layout: post
title: "Git 常用命令"
date: 2019-10-02 18:10:00 +0800
tags: Git VCS
---

![Git](/assets/images/2019-10-02-Git_CMD_1.jpeg)
Git 相比以前 SVN 的集中式版本控制系统有分布开发的优势，提高了团队、个体的开发效率；其特有的哈希存储系统也保证了内容的完整性(后来的区块链技术也是类似的逻辑)。

# 基本原理

## Git 保存数据的几个(抽象)位置

![Git](/assets/images/2019-10-02-Git_CMD_2.png)

- Working directory
  工作目录，距离用户最近，是直接操作的那个文件夹
- Index Staging area
  索引操作的舞台(临时区)，可以从这里 commit 到真正的仓库
- Local repository
  本地的数据仓库，进入真正的 Git 文件系统保存
- Upstream
  远端的 Git 库，用于分布式配合

其中本地仓库又分为 origin 和 local，origin branch 通常是只读使用、local branch 可以直接操作。

另外，还有一个 stash 栈区域，可以保存临时文件。

## Git 文件系统中的元素

Git 使用 hash 存储系统，系统中每个元素都形成一个 hash，通过元素中的指针记录相关关系。这样重复的文件只要一个 hash 就可以代表了，避免重复存储。

![Git](/assets/images/2019-10-02-Git_CMD_3.jpg)

- blob 一个文件的 hash 及相关信息
- tree 一个文件夹的 hash 及其子文件的指针信息
- commit 一个仓库的快照，以 commit 链表的方式表示历史记录
- branch 由 commit 链表形成分支结构
- tag commit 的别名，比如常见的 HEAD 是当前 branch 最近一次 commit 的别名

## 项目文件结构

`.git` 文件夹存储除工作目录外的 git 数据

- config 文件
  本项目的配置文件，如果配置文件中没有描述，则使用全局配置文件的设置项
- HEAD
  文件夹 本地创建的 branch 的引用信息
- refs
  origin 中的引用信息
- objects
  真正的文件压缩数据

另外在项目中，通过`.gitignore`文件存储忽略文件信息

# 配置项操作

`git config xxx`

`git config [--local] configName "configValue"` 默认将配置项记录在本项目的`./.git/config`文件中，只在当前项目起作用。

`git config --golobal configName "configValue"` 使用全局配置文件，在所有未设定的项目中起作用。

`git config --unset configName` 删除配置项。

## 记住密码

```
git config --global credential.helper store
```

在用户主目录的 `.gitconfig` 文件中生成下面的配置。

```
[credential]
	helper = store
```

如果没有`--global`，则在当前项目下的`.git/config`文件中添加。

## 设定 git 操作的账号

```
git config user.name "myUserName"
git config user.email "myUser@Email"
```

PS: 注意，如果不同项目针对的是不同的法律主体，一定不要搞错了，要及时更换默认的 global 设置。否则可能发生用前一家公司的账号向新公司提交的囧况。

# 常用命令

检出分支
`check out br`
当前工作目录的变更文件也会被带到新检出的目录

merge 分支内容到当前工作目录
`git merge br`

rebase 分支内容到当前工作目录
`git rebase br`如果中间产生冲突，则需要解决冲突，然后`git rebase --continue`如果冲突并没有实际的文件，则只需要`git rebase --skip`

## add

将文件添加到 stage 准备 commit

`git add xxx/xxx.xxx`
添加某个文件

`git add .`
添加所有变更文件，包括以前没有版本控制的文件

- `-u` update, 添加所有已存在于 index 的变更文件
- `-A` all, 相当于`git add .`

## commit

将 stage 的代码提交到当前 branch

`git commit`

- `-a` add, 在 commit 前先执行`git add -u`将已存在的变更文件放入 stage
- `-m` message, 后面添加 log 内容

`git commit --amend -m "New commit message"`
修改最后一次提交的 message，如果已经 push 过，则再次 push 时需要加 -f。

## reset

`git reset [--模式] [commit-hash]`
将当前 branch 的 index 从 HEAD 设置到特定的 commit。如果不填 commit，默认是 HEAD。这个过程中会取消 stage 中的文件。

- `--mixed` 默认模式，改变 index 但不改变 working directory
- `--soft` 只变更 HEAD 指向，index 和 working directory 都不改变，如果指向了过去的 commit，则后来的所有变更都将存在于 stage。
- `--hard` 重置 index 和 working directory，丢弃所有变更

`git reset --hard b6918745efad2fe4e5a41b65cfd0571e02410bd4`
强制回退当前 branch 的主线

## push

将本地版本推送到远端

`git push origin br`
第一次推送分支到远程

- `-u` upstream，在推送的同时设定当前 branch 的远端映射，适用于第一次 push

## log

`git log`
显示每个 commit 对应的 hash 及 log message。

- `--graph` 增加分支图的显示；
- `--decorate` 显示 commit 的引用;
- `--simplify-by-decoration` 只显示被 branch 或 tag 引用的关键 commit;
- `--oneline` 每个 commit 精简于一行显示，省略细节信息;
- `--all` 表示所有 branch，也可以替换为多个 branch 名;

## branch

`git branch br`
从当前工作目录创建分支，创建时并不会 checkout 到新 branch

`git checkout -b new_branch_name [remotes/origin/]old_branch`
创建 branch 并 checkout 到该 branch

`git branch -vv`
查看当前本地 branch 的信息，包括每个 branch 对应的远端 branch 名。

`git branch --set-upstream-to origin/xxx`
设置当前 branch 的远端 branch 名

`git branch --unset-upstream`
取消当前 branch 与远端 branch 的映射关系

`git branch -a`
查看所有 branch 信息，远端 branch 名。

`git branch -D br`
删除本地分支或本地的 origin 分支

`git push origin :br (origin 后面有空格)`
删除远程分支

## revert

恢复某个被修改或删除的问题件
`git checkout xxx/xxx.xxx`

恢复某文件到某个历史版本
`git checkout d98a0f565804ba639ba46d6e4295d4f787ff2949 xxx/xxx.xxx`

`git revert commit_hash`
将特定一次 commit 代码回滚，再次提交时这个回滚的结果会作为新的一次 commit。

## tag

为某个版本建立一个快照并打上标签，用于基线控制。

`git tag -l ['v0.1.1.*']`
列出所有的 tag，可以增加模式匹配字符串。

`git checkout tagName`
checkout 出 tagName 对应的版本，并进入“detached HEAD" ，只读，无法进行更改。

`git checkout -b branchName tagName`
checkout 出 tagName 并创建为一个 branch，可以后续修改。

`git tag v1.1.1`
新建一个轻量级的(lightweight)tag，相当于给当前 commit 一个别名。

`git tag -a v1.1.1 -m 'this is an annoted tag names v1.1.1'`
新建一个带附注(annoted)的 tag，该 tag 对应的版本将形成一个独立的存储，并包含名字、邮箱号、日期、备注、校验等信息，允许使用 GPG(GNU Privacy Guard)来签署和验证。

`git show tagName`
显示 tag 相关信息

`git push origin tagName`
推送 tag 到远端

`git push origin --tags`
推送所有 tag 到远端

## diff

`--stat` 查看概要信息

```

```

`git diff`
查看当前 workspace 已经发生的变更

`git diff xxx/xxx`
查看具体文件在当前 workspace 下发生的变更

`git diff hash1 hash2 --stat`
查看两次 commit 的概要差异，左边是旧版本、右边是新版本，这里的 hash1 hash2 只需要输入一部分就可以了

`git diff HEAD^ HEAD`
commit 名称即使用前缀也不容易记忆，可以使用最近几次 commit 的别名：`HEAD`、`HEAD^`、`HEAD^^`...，分别表示 最后一次 commit、倒数第二次、第三次...

`git diff hash1 hash2 xxx1/xxx1.xx [xxx2/xxx2.xx]`
查看两次 commit 的某[些]文件的具体差异

`git diff hash1 hash2`
查看两次 commit 的所有文件的具体差异

`git diff branch1 branch2`
查看两个 branch 的差异，其他操作类似 hash

## format-patch

生成 patch 文件，与`git apply`命令配合可以打补丁包。与 linux 自带的 patch 相比更适合多层级多文件的情况，另外还保留了 commit log。

`git format-patch hash1[..hash2]` 将(hash1, hash2]生成一系列带序号的 .patch 文件。可以用的几个版本别名：`--root`、`HEAD`、`HEAD^`、`HEAD^^`...，分别表示 初始无 commit 状态、最后一次 commit、倒数第二次、第三次...

`git format-patch -1 hash` 只生成一个 commit 对应的 patch

## apply

应用一个 patch

`git apply xxx/xxx.patch`
打一个补丁文件

- `--stat` 查看 patch 的概要情况
- `--check` 检查是否能够打上，如果没有报错则说明可以打上
- `--reject` 强行打补丁，冲突的部分会保存为`.rej`文件

## am

apply manager，批量执行 apply 动作

`git am xxx/*.patch`
按照文件序号打上一系列补丁文件

- `--signoff` 在打补丁时在 commit log 中加上自己的签名，有时可能使用的是别人的补丁包

`git am --abort` 放弃之前打上的补丁

`git am --resolved` 与`--continue`等价，打补丁冲突后，手动解决了冲突，然后执行这条命令继续打 patch

## stash

将临时变更缓存在当前 git 库的公共区域，在需要时使用。

`git stash`
将临时未 stage 的变更缓存在栈中

`git stash list`
查看栈列表

`git stash show`
显示栈顶变更概要

`git stash pop`
出栈一次，将变更覆盖到当前工作空间

`git stash drop`
抛弃缓存栈

# 示例场景

## 从 dev 创建 branch_my 进行开发，完毕后 merge 到 dev 然后提交

```
// 创建branch_my
git checkout -b branch_my dev	(如果已创建branch_my可以直接checkout)
// 进行编辑
git add ...
git commit ...
git stash (保存临时文件)
// 开始合并
git checkout dev
git pull --rebase
git checkout branch_my
git rebase dev
// 解决冲突
git checkout dev
git rebase branch_my
// 再次确保可以push
git pull --rebase
// push
git push
// 回到branch_my继续工作
git checkout branch_my
git stash pop
git checkout
```

## 从 dev 创建 my 进行开发，通过 MergeRequest 提交代码到 dev。

```
// 创建 my
git checkout -b my origin/dev
// 进行编辑
git add ...
git commit ...
// 合并
git fetch
git rebase origin/dev
// 解决了冲突后，可以push
git push origin my
// 之后可以提交MergeRequest
```

## 拷贝了不同 PC 上的 git 项目文件夹，缺少了 upsteam 信息

```
git branch --set-upstream-to=origin/branchName1 branchName2
```

通过上面语句可以补足上游信息，branchName 可以相同也可以不同。

## 将`git format-patch`生成的一系列文件补丁打到项目、解决冲突

```
// 把 patch 文件放在项目外文件夹(如："../patches")，避免妨碍 git 操作
git am ../patches/*.patch
// 遇到了冲突，停止在 `3.patch` 这个文件上
git apply --reject ../patches/3.patch
// 强行打补丁后，生成了 `3.rej` 文件，描述了冲突点
// 编辑代码，将所有冲突解决，将变更加入 stage
git add .
git am ../patches/*.patch --continue
// 遇到冲突持续解决，直到最后完成补丁
```
