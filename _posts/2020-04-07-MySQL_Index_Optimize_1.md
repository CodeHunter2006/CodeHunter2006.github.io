---
layout: post
title: "MySQL 索引优化1"
date: 2020-04-07 23:00:00 +0800
tags: MySQL
---

# Mysql 查询 SQL 或索引设置不当时会有哪些问题？

- 性能低
- 执行时间长
- 等待时间长
- SQL 语句结构差(连接查询)
- 索引失效
- 服务器参数设置不合理(缓冲、线程)

# SQL 的执行过程

从我们输入的 SQL 到最终得到结果，进行了下面步骤：写 SQL->解析器->优化器->执行器

- 所以可能会发生优化其篡改语句的情况

## 编写过程

```SQL
select distinct...from...join...on...where...group by...having...order by...limit
```

## 解析过程

```SQL
from...on...join...where...group by...having...select distinct...order by...limit
```

由于编写和执行存在很大差异，所以我们要按照最终执行的过程去做优化

# SQL 的优化

SQL 的优化，主要是围绕索引进行

## 索引

### 索引的缺点

- 降低 IO 操作次数，通过 B+树结构减少比较次数和深度，三层 B+树可存放上百万
- 降低 CPU 使用率，索引是有序的，无需排序

### 索引的缺点

- 索引本身容量很大，可以存放在内存/硬盘中(通常是硬盘)
- 索引只适合容量小的字段，大容量字段做索引成本太大
- 索引可以提高查询效率，但是增、删、改的成本很高
- 索引不适合很少使用的列，在 where 中被使用时才能起作用

### 索引分类

- 单值索引 单列索引，一个表可以有多个单值索引
- 唯一索引 是单值索引，不能重复。比如: id
- 复合索引 多个列顺序组合构成。复合索引查找时无需全部命中。
- 主键索引 唯一索引+非 NULL

## expain

在 SQL 前加上`explain`可以查询执行计划，模拟 SQL 优化器执行 SQL 语句，从而分析自己的 SQL 被执行的情况。

### 显示的字段及其意义:

- id 优先级
- select_type 查询类型(PIMARY/SUBQUERY)
- table 表
- type 索引类型
- possible_keys 预测用到的索引
- key 实际用到的索引
- key_len 实际使用索引的长度，可以通过长度反推用到了什么索引
- ref 表间的引用关系
- rows 通过索引查到的数据个数
- extra 额外信息

### explain 各字段用法

- id 值相同，从上向下顺序执行; 值不同，数值越大越优先执行;
  - 多表联查，id 值相同，优化器会把数据量小的表优先查询，这样做笛卡尔积时中间结果数据量更小
  - 多表联查可以转换为嵌套子查询，id 值不同，内层查询优先级更高
