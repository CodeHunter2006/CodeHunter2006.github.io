---
layout: post
title: "Go Unsafe"
date: 2020-04-16 23:00:00 +0800
tags: Go
---

![Circuit Breaker](/assets/images/2020-04-16-Go_unsafe_1.jpg)
记录一些 unsafe 包相关内容。(图片与 unsafe 无关，只是可爱: )

# 内存对齐

## 内存对齐的原因

先要高清下面的几个概念：

- **字节** 8 位组成一个字节;
- **字符** 根据编码格式、字符集，一个字符可能占不同容量;
- **字长** CPU 的处理单位、数据总线的位数，32 位是 4 字节、64 位是 8 字节;

对于**CPU**来说，时钟周期是最重要的指标之一，每个时钟周期只能处理一个字长的数据，符合它字长的整数倍的数据处理速度会最优，所以当数据字长不足字长整数倍时，编译器会自动根据目标操作系统的位数进行**内存对齐**优化。
如果代码中存在过多 padding 的情况，就会浪费时钟周期，不过通常效率不会低太多，手动优化后可能提高 30%。

```Go
type TestClass struct {
    a byte
    b int32
    c byte
}
fmt.Println(unsafe.Sizeof(TestClass{}))
```

上面示例对象`TestClass{}`在 32 位系统下的容量应该是 1 + 4 + 1 = 6 字节，但实际输出是 12 = 1 + 3(padding) + 4 + 1 + 3(padding)

## 自动对齐策略

- 每个大于等于字长的字段，都要从一个整字长开始，前面如果不整，则需要 padding 对齐
- 结构体如果最后没有对齐，则末尾 padding 对齐
- 对于空结构体，如果在另一个结构体内靠前的字段，不会影响结果，也比较省容量；如果放在最后，则需要至少占 1 字节然后再对齐，原因是结尾往往用来识别对象边界，不允许 0 字节的字段。这点和 C++空对象一样，C++空对象也要占 1 字节。
- 为什么不能直接在编译时自动调整顺序优化对齐？ 因为很多结构体操作要基于字段顺序，所以不能随意变动

## 优化方式

- 将 struct 中的成员从大到小排列，这样不容易出现需要 padding 的情况
- 可以用下面方式手动填充对齐(32 位系统)

```Go
type TestClass struct {
    a byte
    _ [3]byte
    c int32
}
```

## 常用工具

[对齐显示工具](https://github.com/ajstarks/svgo)

用 SVG 矢量图显示对象结构，包括 padding 等结构

[优化工具](http://honnef.co/go/tools)

## 其他

- 在 32bit 平台下进行 64bit 原子操作要求必须 8 字节对齐，否则程序会 panic
  在 32 位系统下，int64 本质上就是两个 int32 合在一起实现的，如果不进行 64 位对齐，原子操作 CPU 会无法支持。
  这是目前的局限，需要程序员自己遵守。
  如果对性能要求没那么高，可以用锁来实现原子操作。
