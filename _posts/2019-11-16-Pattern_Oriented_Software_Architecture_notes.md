---
layout: post
title: "面向模式的软件架构 读书笔记"
date: 2019-11-22 23:00:00 +0800
tags:
---

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_1.png)
《Pattern-Oriented Software Architecture--Volume 1--A System of Pattern》中文版于 2013 年出版，被公认为是架构师的必读读物，与《设计模式》同被奉为经典。

<TODO 全文读后感>

- 本书的知识体系发源于《设计模式》，但是又提高了一个层次，以更通用的视角总结模式
- 模式有助于将复杂的代码抽象成可学习的内容，提高学习效率、提高沟通效率
- 模式的实现并不局限于特定的范式或语言(这正是我之前把 C++中使用的设计模式应用于 Javascript 时的感受)
- 以前只知道系统设计要按照分层结构(Layers)，现在知道这其实只是其中一种模式，只不过这种模式使用较广泛

# 第一章 模式

## 1. 模式是什么？

模式最早在建筑学中被使用，建筑师 Christopher Alexander: "简而言之，模式既是现实世界中的一件作品，又是如何及何时创作该作品的规则。"

- 建筑示例：
  - 人性需求：1.既想舒适地坐下来。2.又想光线充足的地方。
  - 设计模式：低矮的窗台 + 舒适的座椅
  - 解释：上面两种元素缺少一种，都会让人很不舒服，而组合在一起往往适合某个场景。

* 软件示例：
  - 软件需求：1.带人机界面的程序，对应的有底层数据。2.界面会经常变化、并且可能有多个界面描述同一数据。3.界面对数据会有操作，可以改变数据。
  - 设计模式：MVC 设计模式
  - 解释：MVC 三个层正好满足了需求，在界面变更时减少了代码变更。

**软件架构模式**描述了在特定设计情形下反复出现的设计问题，并提供了已得到充分证明的通用解决方案摘要。解决方案摘要描述模式的组件、组件的职责和关系，以及这些组件协作的方式。

## 2. 模式之所以为模式

- 模式三要素
  - 背景 引发设计问题的背景情况
  - 问题 在特定背景下反复出现的一系列作用力
  - 解决方案 平衡这些作用力的配置方式
    - 结构 组件和组件之间的关系
    - 行为 运行阶段的行为

## 3. 模式类型

模式的规模和抽象程度各异，我们将模式分为三类：

1. Architectural Patterns(架构模式)
   描绘基本的软件系统组织纲要，提供了一组预定义的子系统，指出了这些子系统的职责，也包含用于子系统间关系进行组织的规则和指南。
   - 例如：MVC 模式就是一个架构模式，指定了交互式软件系统的总体结构。
2. Design Patterns(设计模式)
   提供了对软件系统的子系统、组件或它们之间的关系进行改进的纲要，描绘了对彼此通信的组件进行组织的常见结构，可解决特定背景下的一般性设计问题。
   - 例如：Observer(观察者模式)，比架构模式小，可以独立于编程语言和编程范式(paradigm)，可以有效的改进子系统的协作。
3. Idiom(方言，译作成例)
   是一种低层(low-level)模式，针对的是特定的编程语言。成例阐述如何使用给定的语言的功能来实现组件或组件间关系的特定方面。
   - 例如：Counted Pointer 模式，可以用于 C++的引用计数智能指针。而其它很多语言如 Go 就不需要这样的模式。

## 4. 模式之间的关系

1. 改进，例如 MVC 模式就是由多个更小的 Observer 模式改进而来。
2. 变种，例如 Document-View 模式是 MVC 的变种，更适合文档的编辑，但通知也更局限于文档编辑。
3. 组合，例如 利用 Forwarder-Receiver + Proxy 实现 RPC。

## 5. 模式的描述

描述、记录模式的目的是让别人也理解新找到的模式，能够用相同的语言、词汇来讨论模式，对于没有接触过该模式的人可以通过描述尽快把握模式的精髓。描述模板如下：

1. Name(名称)
   模式的名称和摘要
2. Also Known As(别名)
   模式的其它名称——如果有的话
3. Example(示例)
   一个真实的示例，证明问题确实存在，对即将介绍的模式确实有需求。在整个模式的描述中，将通过这个示例来说明解决方案和实现。
4. Context(上下文/背景)
   模式可能适用的情形
5. Problem(问题)
   模式解决的问题，包括涉及的作用力
6. Solution(解决方案)
   模式背后的基本解决原则
7. Structure(静态结构)
   详细说明模式的结构，包括每个参与组件的 CRC 卡(Classes, Responsibilities, Collaborations，面向对象设计中对一个类的描述)以及一个 OMT 类图(也可以用 UML 类图)
8. Dynamics(动态行为)
   在一些情景下，描述了模式运行阶段的行为。可以用序列图表示
9. Implementation(实现)
   模式实现指南。这些指南并非不变的规则，应根据实际需求调整实现
10. Example Resolved(示例解答)
    在前面没有涉及，但对示例的解决至关重要的各个方面进行讨论
11. Variants(变种)
    简要地描述当前模式的变种或具体化(specialization)
12. Known Uses(已知应用)
    模式在既有系统中的应用
13. Consequences(结果)
    模式提供的优点及潜在的缺点
14. See Also(参考)
    列举其它一些模式，它们要么解决了类似的问题，要么有助于改进当前模式

## 6. 模式与软件架构

- 模式可以作为我们思维的组件，在设计系统时使用。相比继承、多态这种架构技术，模式更加具体。
- 为了有效的使用模式，要将模式组织成模式系统(pattern system)。这种关系组织方式比模式分类(pattern catalog)更加有效，指出了模式之间错综复杂的关系，有助于寻找适合解决问题的模式及其替代方案。
- **模式的实现并不局限于特定的范式或语言**，例如：既是不实用继承(面向对象范式)实现 Proxy，代码差别也很小；利用函数指针完全可以用 C 语言实现 Strategy 模式。

# 第二章 架构模式

## 2. 从混乱到有序

在需求没有明确或已部分明确的情况下，只按照需求应用领域的规则来切分模块、类是无助于解决问题的。一方面，最终的系统将包含大量与应用领域没有直接关系的组件；另一方面，我们要求系统不仅能正常运行，还要具备一些与应用程序功能没有直接关系的特质，如可移植性、易维护性、易理解性、稳定性(鲁棒性)等。我们将介绍三个以不同方式对系统进行粗略划分的架构模式：Layers、Pipes and Filters、Blackboard。

### Layers

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_2.png)
Layers 架构模式有助于将应用程序划分为多组子任务，其中每组子任务都位于特定抽象层。

- 示例
  网络协议的分层架构

- 背景
  需要分解的大型系统

- 问题
  需要设计一个系统，需要同时解决高层问题和低层问题，而且高层依赖于低层。通常指定了目标平台，高层任务与平台之间的关系并非显而易见，这重要是因为这些任务过于复杂，无法直接使用平台提供的服务来实现。需要平衡下述作用力：

  - 以后修改源码不会波及整个系统，其影响限定在一个组件内，不会影响其它组件。
  - 接口稳定，甚至遵守标准组织制定的标准。
  - 系统的各个部分都可以更换。可使用其它实现替换组件，而不影响其它组件。
  - 未来可能需要打造其它系统，这些系统与当前设计的系统面临着相同的低层次问题。
  - 应将类似的职责编组，让系统更容易理解和维护。
  - 根本没有所谓的标准组件粒度。
  - 复杂度组件需要进一步分解。
  - 跨越组件边界可能影响性能，例如，必须跨越多个组件边界传输大量数据时。
  - 系统将由一个程序员团队打造，因此分工必须明确，在架构设计阶段这种需求常常被忽视。

- 解决方案

  - 笼统的看，解决方案极其简单：将系统划分成适当的层数，并将它们堆叠起来。从最低的抽象层开始，沿抽象阶梯往上走。第 i 层的请求，将转换为发给 i-1 层的请求，每层的所有组件都必须处于相同的抽象层级。每层的服务都实现了一种功能，以有意义的方式组合下一层的服务。另外，服务还可能依赖于同一层的其它服务。

- 结构
  这种结构类似洋葱，每层都将下面的层保护起来，禁止上面的层直接访问它们。
  - 类
    - 第 i 层
  - 职责
    - 提供 i+1 层使用的服务
    - 将子任务委托给 i - 1 层
  - 协作者
    - 第 i - 1 层

* 动态
  - 自上而下的请求，往往需要再分解为更多的自上而下的请求
  - 自下而上的通知，往往会合并或者不合并的向上传递
  - 请求不一定要转发到所有层，如果在中间某层能够处理了就可以直接返回结果
  - 有些层是缓存层，要保存数据，所以是有状态的；有些层是只做转发、无状态的，开发起来较简单
  - 两个包含 N 层的栈相互通信，其中的栈被称为协议栈，这是通信协议中常见的情景

- 实现
  下面的步骤并不是必须顺序执行或必不可少的，要根据实际程序开发改变，往往是"悠悠球"式的设计过程。

  1. 定义将任务划分到不同层的抽象准则。
  2. 根据抽象准则确定抽象层级数。
  3. 给每层命名并分派任务。
  4. 规范服务。最重要的实现原则是相邻层界限分明，即任何组件都不跨越多层。在层之间共享模块有悖于严格分层的原则。将更多服务放在高层通常胜过放在低层，低层应尽量保持"苗条"，这就是"倒置的重用金字塔"。
  5. 完善层次划分，反复执行 1~4 步。
  6. 规范每层的接口。通常下层对上层来说是一个"黑盒"，只提供一个统一的接口(flat interface)。通常尽量采用"黑盒"而不是"白盒"或"灰盒"。可以利用 Facade 进行封装，如果实在需要知道下层内部结构，可以利用 Reflection 救场。
  7. 确定隔层的内部结构。可以利用 Bridge 来提供多种实现、用 Strategy 动态的更换算法。
  8. 规范相邻层之间的通信。通常采用推模型，具体推拉模型之后在 Pipes and Filters 介绍。
  9. 将相邻层解耦。可以用 Reactor 和 Command 模式解耦。
  10. 制定错误处理策略。对于分层架构，处理错误的时间和代码量都会特别高。处理错误时最好能在本层完成，如果非要向上抛出则一定要先转换为上层可以理解的出错信息，并且是比较笼统的错误信息。如果不这样做，上层就会因为不了解内部结构而感到莫名其妙。例如我们常见的"404"错误。

- 示例解答
  FTP 应用间通信的功能，实际上是 FTP->TCP->IP->以太网->物理连接->...->FTP 的方式传输的，也是分了 5 层(包含物理连接)。

- 变种
  Relaxed Layered System. 层间关系不那么严格，每层都能使用下面的所有服务。这会使得系统难以维护，常见于操作系统，变化不频繁、性能要求比可维护性要求更高。
  Layering Through Inheritance. 常见于面向对象系统中。将低层实现为基类、高层通过继承的方式使用积累。优点是高层可以根据需要修改低层的服务；缺点是高层和低层紧密耦合，当低层修改后，所有代码需要重新编译。

- 已知应用

  - 虚拟机。JVM 就是一种低层平台。
  - API。API 通常就是低层向高层提供的。
  - 信息系统(IS)。通常包含四层，由上到下分别为：表示层、应用程序逻辑层、领域层、数据库层。
  - WindowsNT，属于 Relaxed Layered System。

- 效果

  - 优点：

    - 隔层可重用
      最佳实践：抽象明确、黑盒模式、良好的文档
    - 支持标准化
    - 限制了依赖关系的范围
      提高可移植性、可测试性
    - 可更换性
      用 Adapter 模式可以更换实现；用 Bridge 模式可以通过指针动态更换实现；硬件接口更换不同设备

  - 缺点：
    - 行为变化可能引发雪崩效应
      例如低层网络性能变差，为了适应，各层都要改
    - 效率低下
      分层结构由于层间的数据转换，通常比整体结构(对象海洋)效率更低
    - 不必要的工作
      如果低层服务做了高层未要求的多余或重复的工作，将对性能带来负面影响。例如用户态到内核态的切换，未必有检查的必要。
    - 难以确定正确的层次粒度

## 3. 分布式系统

## 4. 交互式系统

## 5. 可适应系统

# 第三章 设计模式

## 1. 导言

## 2. 结构分解模式

## 3. 工作组织模式

## 4. 访问控制

## 5. 管理模式

## 6. 通信模式

# 第四章 成例

## 1. 导言

## 2. 成例的用途

## 3. 成例与风格

## 4. 到哪里去寻找成例

# 第五章 模式系统

## 1. 模式系统是什么

## 2. 模式分类

## 3. 选择模式

## 4. 作为实现指南的模式系统

## 5. 模式系统的演化

## 6 总结

# 第六章 模式与软件架构

## 1. 导言

## 2. 软件架构中的模式

## 3. 软件架构支持技术

## 4. 软件架构的非功能特征

## 5. 总结

# 第七章 模式界

## 1. 起源

## 2. 领军人物及其成果

## 3. 模式界

# 第八章 模式的发展方向

## 1. 模式挖掘

## 2. 模式的组织和模式索引

## 3. 方法和工具

## 4. 算法、数据结构和模式

## 5. 模式的规范化

## 6. 结语

<TODO 按章节拆解>
