---
layout: post
title: "面向模式的软件架构 读书笔记"
date: 2019-11-22 23:00:00 +0800
tags:
---

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_1.png)
《Pattern-Oriented Software Architecture--Volume 1--A System of Pattern》中文版于 2013 年出版，被公认为是架构师的必读读物，与《设计模式》同被奉为经典。

// TODO 全文读后感

- 本书的知识体系发源于《设计模式》，但是又提高了一个层次，以更通用的视角总结模式。将模式分为三个层次：架构模式、设计模式和成例(方言)。介绍了常用的架构模式、成例，补充了《设计模式》中没有介绍但常用的一些模式。
- 模式有助于将复杂的代码抽象成可学习的内容，提高学习效率、提高沟通效率
- 模式的实现并不局限于特定的范式或语言(这正是我之前把 C++中使用的设计模式应用于 Javascript 时的感受)
- 以前只知道系统设计要按照分层结构(Layers)，现在知道这其实只是其中一种模式，只不过这种模式使用较广泛

# 第一章 模式

## 1. 模式是什么？

模式最早在建筑学中被使用，建筑师 Christopher Alexander: "简而言之，模式既是现实世界中的一件作品，又是如何及何时创作该作品的规则。"

- 建筑示例：
  - 人性需求：1.既想舒适地坐下来。2.又想光线充足的地方。
  - 设计模式：低矮的窗台 + 舒适的座椅
  - 解释：上面两种元素缺少一种，都会让人很不舒服，而组合在一起往往适合某个场景。

* 软件示例：
  - 软件需求：1.带人机界面的程序，对应的有底层数据。2.界面会经常变化、并且可能有多个界面描述同一数据。3.界面对数据会有操作，可以改变数据。
  - 设计模式：MVC 设计模式
  - 解释：MVC 三个层正好满足了需求，在界面变更时减少了代码变更。

**软件架构模式**描述了在特定设计情形下反复出现的设计问题，并提供了已得到充分证明的通用解决方案摘要。解决方案摘要描述模式的组件、组件的职责和关系，以及这些组件协作的方式。

## 2. 模式之所以为模式

- 模式三要素
  - 背景 引发设计问题的背景情况
  - 问题 在特定背景下反复出现的一系列作用力
  - 解决方案 平衡这些作用力的配置方式
    - 结构 组件和组件之间的关系
    - 行为 运行阶段的行为

## 3. 模式类型

模式的规模和抽象程度各异，我们将模式分为三类：

1. Architectural Patterns(架构模式)
   描绘基本的软件系统组织纲要，提供了一组预定义的子系统，指出了这些子系统的职责，也包含用于子系统间关系进行组织的规则和指南。
   - 例如：MVC 模式就是一个架构模式，指定了交互式软件系统的总体结构。
2. Design Patterns(设计模式)
   提供了对软件系统的子系统、组件或它们之间的关系进行改进的纲要，描绘了对彼此通信的组件进行组织的常见结构，可解决特定背景下的一般性设计问题。
   - 例如：Observer(观察者模式)，比架构模式小，可以独立于编程语言和编程范式(paradigm)，可以有效的改进子系统的协作。
3. Idiom(方言，译作成例)
   是一种低层(low-level)模式，针对的是特定的编程语言。成例阐述如何使用给定的语言的功能来实现组件或组件间关系的特定方面。
   - 例如：Counted Pointer 模式，可以用于 C++的引用计数智能指针。而其它很多语言如 Go 就不需要这样的模式。

## 4. 模式之间的关系

1. 改进，例如 MVC 模式就是由多个更小的 Observer 模式改进而来。
2. 变种，例如 Document-View 模式是 MVC 的变种，更适合文档的编辑，但通知也更局限于文档编辑。
3. 组合，例如 利用 Forwarder-Receiver + Proxy 实现 RPC。

## 5. 模式的描述

描述、记录模式的目的是让别人也理解新找到的模式，能够用相同的语言、词汇来讨论模式，对于没有接触过该模式的人可以通过描述尽快把握模式的精髓。描述模板如下：

1. Name(名称)
   模式的名称和摘要
2. Also Known As(别名)
   模式的其它名称——如果有的话
3. Example(示例)
   一个真实的示例，证明问题确实存在，对即将介绍的模式确实有需求。在整个模式的描述中，将通过这个示例来说明解决方案和实现。
4. Context(上下文/背景)
   模式可能适用的情形
5. Problem(问题)
   模式解决的问题，包括涉及的作用力
6. Solution(解决方案)
   模式背后的基本解决原则
7. Structure(静态结构)
   详细说明模式的结构，包括每个参与组件的 CRC 卡(Classes, Responsibilities, Collaborations，面向对象设计中对一个类的描述)以及一个 OMT 类图(也可以用 UML 类图)
8. Dynamics(动态行为)
   在一些情景下，描述了模式运行阶段的行为。可以用序列图表示
9. Implementation(实现)
   模式实现指南。这些指南并非不变的规则，应根据实际需求调整实现
10. Example Resolved(示例解答)
    在前面没有涉及，但对示例的解决至关重要的各个方面进行讨论
11. Variants(变种)
    简要地描述当前模式的变种或具体化(specialization)
12. Known Uses(已知应用)
    模式在既有系统中的应用
13. Consequences(结果)
    模式提供的优点及潜在的缺点
14. See Also(参考)
    列举其它一些模式，它们要么解决了类似的问题，要么有助于改进当前模式

## 6. 模式与软件架构

- 模式可以作为我们思维的组件，在设计系统时使用。相比继承、多态这种架构技术，模式更加具体。
- 为了有效的使用模式，要将模式组织成模式系统(pattern system)。这种关系组织方式比模式分类(pattern catalog)更加有效，指出了模式之间错综复杂的关系，有助于寻找适合解决问题的模式及其替代方案。
- **模式的实现并不局限于特定的范式或语言**，例如：既是不实用继承(面向对象范式)实现 Proxy，代码差别也很小；利用函数指针完全可以用 C 语言实现 Strategy 模式。

# 第二章 架构模式

## 2. 从混乱到有序

在需求没有明确或已部分明确的情况下，只按照需求应用领域的规则来切分模块、类是无助于解决问题的。一方面，最终的系统将包含大量与应用领域没有直接关系的组件；另一方面，我们要求系统不仅能正常运行，还要具备一些与应用程序功能没有直接关系的特质，如可移植性、易维护性、易理解性、稳定性(鲁棒性)等。我们将介绍三个以不同方式对系统进行粗略划分的架构模式：Layers、Pipes and Filters、Blackboard。

### Layers

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_2.png)
Layers 架构模式有助于将应用程序划分为多组子任务，其中每组子任务都位于特定抽象层。

#### 示例

网络协议的分层架构

#### 背景

需要分解的大型系统

#### 问题

需要设计一个系统，需要同时解决高层问题和低层问题，而且高层依赖于低层。通常指定了目标平台，高层任务与平台之间的关系并非显而易见，这重要是因为这些任务过于复杂，无法直接使用平台提供的服务来实现。需要平衡下述作用力：

- 以后修改源码不会波及整个系统，其影响限定在一个组件内，不会影响其它组件。
- 接口稳定，甚至遵守标准组织制定的标准。
- 系统的各个部分都可以更换。可使用其它实现替换组件，而不影响其它组件。
- 未来可能需要打造其它系统，这些系统与当前设计的系统面临着相同的低层次问题。
- 应将类似的职责编组，让系统更容易理解和维护。
- 根本没有所谓的标准组件粒度。
- 复杂度组件需要进一步分解。
- 跨越组件边界可能影响性能，例如，必须跨越多个组件边界传输大量数据时。
- 系统将由一个程序员团队打造，因此分工必须明确，在架构设计阶段这种需求常常被忽视。

#### 解决方案

- 笼统的看，解决方案极其简单：将系统划分成适当的层数，并将它们堆叠起来。从最低的抽象层开始，沿抽象阶梯往上走。第 i 层的请求，将转换为发给 i-1 层的请求，每层的所有组件都必须处于相同的抽象层级。每层的服务都实现了一种功能，以有意义的方式组合下一层的服务。另外，服务还可能依赖于同一层的其它服务。

#### 结构

这种结构类似洋葱，每层都将下面的层保护起来，禁止上面的层直接访问它们。

- 类
  - 第 i 层
- 职责
  - 提供 i+1 层使用的服务
  - 将子任务委托给 i - 1 层
- 协作者
  - 第 i - 1 层

#### 动态

- 自上而下的请求，往往需要再分解为更多的自上而下的请求
- 自下而上的通知，往往会合并或者不合并的向上传递
- 请求不一定要转发到所有层，如果在中间某层能够处理了就可以直接返回结果
- 有些层是缓存层，要保存数据，所以是有状态的；有些层是只做转发、无状态的，开发起来较简单
- 两个包含 N 层的栈相互通信，其中的栈被称为协议栈，这是通信协议中常见的情景

#### 实现

下面的步骤并不是必须顺序执行或必不可少的，要根据实际程序开发改变，往往是"悠悠球"式的设计过程。

1. 定义将任务划分到不同层的抽象准则。
2. 根据抽象准则确定抽象层级数。
3. 给每层命名并分派任务。
4. 规范服务。最重要的实现原则是相邻层界限分明，即任何组件都不跨越多层。在层之间共享模块有悖于严格分层的原则。将更多服务放在高层通常胜过放在低层，低层应尽量保持"苗条"，这就是"倒置的重用金字塔"。
5. 完善层次划分，反复执行 1~4 步。
6. 规范每层的接口。通常下层对上层来说是一个"黑盒"，只提供一个统一的接口(flat interface)。通常尽量采用"黑盒"而不是"白盒"或"灰盒"。可以利用 Facade 进行封装，如果实在需要知道下层内部结构，可以利用 Reflection 救场。
7. 确定隔层的内部结构。可以利用 Bridge 来提供多种实现、用 Strategy 动态的更换算法。
8. 规范相邻层之间的通信。通常采用推模型，具体推拉模型之后在 Pipes and Filters 介绍。
9. 将相邻层解耦。可以用 Reactor 和 Command 模式解耦。
10. 制定错误处理策略。对于分层架构，处理错误的时间和代码量都会特别高。处理错误时最好能在本层完成，如果非要向上抛出则一定要先转换为上层可以理解的出错信息，并且是比较笼统的错误信息。如果不这样做，上层就会因为不了解内部结构而感到莫名其妙。例如我们常见的"404"错误。

#### 示例解答

FTP 应用间通信的功能，实际上是 FTP->TCP->IP->以太网->物理连接->...->FTP 的方式传输的，也是分了 5 层(包含物理连接)。

#### 变种

Relaxed Layered System. 层间关系不那么严格，每层都能使用下面的所有服务。这会使得系统难以维护，常见于操作系统，变化不频繁、性能要求比可维护性要求更高。
Layering Through Inheritance. 常见于面向对象系统中。将低层实现为基类、高层通过继承的方式使用积累。优点是高层可以根据需要修改低层的服务；缺点是高层和低层紧密耦合，当低层修改后，所有代码需要重新编译。

#### 已知应用

- 虚拟机。JVM 就是一种低层平台。
- API。API 通常就是低层向高层提供的。
- 信息系统(IS)。通常包含四层，由上到下分别为：表示层、应用程序逻辑层、领域层、数据库层。
- WindowsNT，属于 Relaxed Layered System。

#### 效果

- 优点：

  - 隔层可重用
    最佳实践：抽象明确、黑盒模式、良好的文档
  - 支持标准化
  - 限制了依赖关系的范围
    提高可移植性、可测试性
  - 可更换性
    用 Adapter 模式可以更换实现；用 Bridge 模式可以通过指针动态更换实现；硬件接口更换不同设备

- 缺点：

  - 行为变化可能引发雪崩效应
    例如低层网络性能变差，为了适应，各层都要改
  - 效率低下
    分层结构由于层间的数据转换，通常比整体结构(对象海洋)效率更低
  - 不必要的工作
    如果低层服务做了高层未要求的多余或重复的工作，将对性能带来负面影响。例如用户态到内核态的切换，未必有检查的必要。
  - 难以确定正确的层次粒度

#### 参考

- Composite Message 是 Composite 模式的变种，以面向对象的方式在层间传输消息。
- Microkernel 架构可视为一种特殊的分层结构。

### Pipes and Filters

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_3.png)
Pipes and Filters 架构模式提供的结构适合用于处理数据流的系统。每个处理步骤都封装在一个过滤器组件中，数据通过相邻过滤器之间的管道传输。通过重组过滤器，可打造多个相关的系统族。

#### 示例

一个可移植的编译器。编译通常要经过下面步骤：词法分析、语法分析、语义分析、中间代码(AuLait Another Universal Language for Intermediate Translation)生成、可选的中间代码优化(针对不同后端)

#### 背景

处理数据流

#### 问题

系统必须对输入数据流进行处理或转换，以单个组件的方式实现这种系统不可行，原因有多个：系统必须由多名开发人员打造；整个系统要完成的任务分多个处理阶段；需求很可能发生变化。需考虑如下作用力：

- 以后可通过更换或重组处理步骤来改进系统，这甚至可以由用户完成
- 相比大型组件，在其他环境中重用小型处理步骤更容易
- 不相邻的处理步骤不共享信息
- 存在不同的输入数据源，如网络连接和提供温度的硬件传感器
- 最终结果能够以各种方式显示和存储
- 如果要求用户将中间结果存储到文件中，供以后进一步处理，将很容易出错
- 应避免同时执行多个处理步骤，如并行或半并行地执行这些步骤

对于事件驱动的交互式系统，就不能划分为一系列执行的阶段，不适用这种架构。

#### 解决方案

架构模式 Pipes and Filters 将系统面临的任务分为多个一次执行的处理步骤。这些步骤通过在系统中传输的数据相关联：一个步骤的输出是下一个步骤的输入。每个处理步骤都由过滤器组件实现。过滤器一边使用数据一边提供数据，而不是等到获得所有输入后才生成输出。这降低了延迟，实现了真正的并行处理。系统的输入由诸如文本文件等数据源提供，而输出进入数据接收器(data sink)，如文件、终端、动画程序等。数据源、过滤器、数据接收器通过管道依次相连，每条管道都在相邻处理步骤之间传输数据。由管道连接的过滤器序列成为处理流水线(processing pipeline)。

#### 结构

- 类
  - 过滤器
- 职责
  - 获取输入数据
  - 对输入数据进行处理
  - 提供输出数据
- 协作者
  - 管道

过滤器组件的三种功能：

- 充实
  通过计算和添加信息来充实数据
- 提炼
  通过浓缩或提取信息来提炼数据
- 转换
  通过改变表示方式来转换数据

过滤器操作可由多种事件触发：

- 下一个流水线元素从过滤器拉取输出
- 前一个流水线元素向过滤器推送输入
- 常见的情况是，过滤器不断地循环，从流水线上游拉取输入，并向下游推送输出

管道指的是过滤器之间、数据源和第一个过滤器之间、最后一个过滤器和数据接收器之间的连接。

- 类
  - 管道
- 职责
  - 传输数据
  - 缓冲数据
  - 同步相邻的主动过滤器
- 协作者

  - 数据源
  - 数据接收器
  - 过滤器

- 类
  - 数据源
- 职责
  - 向处理流水线提供输入
- 协作者

  - 管道

- 类
  - 数据接收器
- 职责
  - 使用输出
- 协作者
  - 管道

#### 动态

- 情景 1
  推式流水线，数据源首先采取行动。数据写入触发被动过滤器采取行动。
- 情景 2
  拉式流水线，控制流程始于数据接收器请求数据。
- 情景 3
  推——拉式流水线，数据源和数据接收器都是被动的。在这里，由第二个过滤器主动发起处理过程。
- 情景 4
  这是 Pipes and Filters 系统更复杂也更为典型的行为。所有过滤器都主动拉取数据、执行计算并推送数据，因此每个过滤器都运行在独立的控制线程中，如作为独立的进程运行。过滤器由它们之间的缓冲管道同步。该情景还表明，使用过滤器可并行地执行程序。

#### 实现

1. 将系统要完成的任务划分为一系列处理阶段，每个阶段都只依赖于前一个阶段的输出。
2. 定义沿管道传递的数据的格式。注意数据类型的传输效率，如用文本表示浮点型效率较低。必须定义输入末尾的方式，可以用\$、Ctrl-D、Ctrl-Z 等标记。
3. 确定如何实现每条管道连接。管道是先进先出缓冲区，可以利用操作系统提供的，也可以直接调用的方式。可以将过滤器实现为独立的线程，并将管道实现为让数据生产者和消费者同步的队列。
4. 设计并实现过滤器。
5. 设计错误处理机制。流水线出错后很难恢复，通常是重启解决。可以使用特殊标记来标记输入数据流，数据原封不动地传输，最终进入输出，在这个过程中出现故障何以在响应阶段重启。另一种方法是使用管道缓冲数据，在过滤器崩溃时用它来重启流水线。
6. 搭配处理流水线。

#### 示例解答

在编译器的实现中，我们采用了全局的符号表，每个过滤器都可以访问。

#### 变种

tee and join 流水线系统。修改过滤器的入口和出口只能有一个的规定，允许过滤器有多个入口和多个出口。将流水线搭建成有向图，甚至可以包含反馈回路。如 UNIX 中的过滤器程序 tee。

#### 已知应用

- UNIX shell 和众多过滤器程序使 Pipes and Filters 随 UNIX 得以风行。
- CMS Pipelines 是 IBM 大型机操作系统的一种扩展。
- LASSPTools 是一个支持数值分析和图形学的工具集。

#### 效果

- 优点：
  - 不需要中间件，但也可以使用。
  - 可更换过滤器。通常不能在运行阶段更换过滤器。
  - 可重组过滤器。如 UNIX 管道机制。
  - 可重用过滤器组件。
  - 可快速创建流水线原型。
  - 效率因并行处理得以提高。

* 缺点：
  - 共享状态信息的开销高昂或缺乏灵活性。
  - 通过并行处理提高效率的初衷常常成为泡影，原因如下：
    - 相比由单个过滤器执行所有计算，在过滤器之间传输数据的开销可能更高。使用网络连接过滤器时尤其如此。
    - 有些过滤器使用完所有输入后才生成输出，这要么是它执行的任务(如排序)使然，要么是设计不佳，例如在应用程序允许逐渐处理的情况下没有这样做。
    - 在只有一个处理器的计算机上，线程或进程切换上下文的开销大。
    - 通过管道同步过滤器而管道缓冲区很小时，频繁地开启和停止管道效率低下。
  - 数据转换开销。
  - 错误处理。错误处理是 Pipes and Filters 模式的阿喀琉斯之踵。如果用于关键任务系统，根本不可能重启流水线或对错误置若罔闻，应该考虑其他架构(如 Layers)来打造系统。

#### 参考

对于必须可靠运行的系统，Layers 模式更适合，更容易实现错误处理机制。而 Pipes and Filters 模式的重要特征——轻松地重组和重用组件，这是 Layers 模式不具有的。

### Blackboard

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_4.png)
Blackboard 架构模式对还未找到确定解决策略的问题很有帮助。在 Blackboard 模式中，多个专业子系统通过集思广议，获得可能的部分解或近似解。

PS：Blackboard 的执行过程看起来像是状态模式，寻找最优解的过程正好适用于 AI 类项目。

#### 示例

语音识别，需要跨领域完成功能。

#### 背景

未找到或找不到确定解决之道的不成熟领域。

#### 问题

没有可行而确定的解决方案将原始数据转换为高级数据结构(如图表或英语词组)。例如：视觉识别、图像识别、语音识别、监控等。这种问题具有如下特点：可分解成多个子问题，但每个子问题都属于不同的专业领域。要解决子问题，需要使用不同的表示法和范式。

上述有些领域的信息可能不可靠或不准确，且每个转换步骤都可能提供多个解。在这种情况下，通常能找到最优解，但也可能只有次优解，甚至无解。因此，如果要根据其结果作出重要决策，必须对结果进行验证。

作用力如下：

- 不可能在合理的时间内遍历整个解空间。
- 鉴于领域还不成熟，可能需要对同一个子任务尝试不同的算法。因此，各个模块应易于更换。
- 子问题的算法各不相同。例如，识别波形中语音片段的算法就与根据单词序列生成词组的算法毫无关系。
- 输入、中间结果和最终结果的表示方式各不相同，而不同算法是根据不同范式实现的。
- 一个算法通常使用另一个算法的结果。
- 涉及不可靠的数据和近似解。
- 算法的执行顺序不确定时还可能要求支持并行。应尽可能避免严格按照顺序执行的解决方案。

#### 解决方案

Blackboard 架构背后的理念是，一系列独立的程序携手合作，致力于处理同一个数据结构。每个程序善于解决整项任务的某一部分；所有程序同理合作，致力于找到解决之道。

#### 结构

对系统进行划分，使其包含一个黑板组件、一系列知识源以及一个控制组件。

**黑板**为中央数据存储区，解空间中的元素及控制数据都存储在这里。我们使用术语词表(vocabulary)表示可能出现在黑板上的所有数据元素。黑板提供了一个接口，让所有知识源都能够对其进行读写。

解空间中的所有元素都可能出现在黑板上。对于在问题解决过程中得到的解，如果它出现在黑板上，我们便称之为推测(hypothesis)或黑板项(blackboard entry)。遭到否决的推测将从黑板中删除。

每个**知识**源都是一个独立的子系统，解决整个问题的特定方面。这些知识源解决的子问题一起构成问题域。任何一个知识源都无力独自完成系统面临的任务，找到解的唯一途径是整合多个知识源的结果。

知识源通常运行在两个抽象层级。如果知识源实现的是正向推理，将把解转换为上一个层级的解；进行反向推理的知识源在下一个层级寻找证据，如果找不到证据，可能退回到上一层级的解。

- 类
  - 黑板
- 职责
  - 管理中央数据
- 协作者

* 类
  - 知识源
* 职责
  - 评估自己的适用性
  - 计算结果
  - 更新黑板
* 协作者
  - 黑板

每个知识源都负责判断自己在什么情况下可帮助找到解，因此知识源分为条件部分和行动部分。条件部分对求解过程的当前状态(写在黑板上)进行评估，以判断自己能否助一臂之力。行动部分生成结果，可能导致黑板的内容发生变化。

**控制组件**运行一个监视黑板内容变化的循环，并决定接下来采取什么措施。它根据知识运用策略决定激活哪个知识源，让它发起评估。这种策略的依据是黑板上的数据。

该策略可能依赖于控制知识源，这些特殊的知识源不直接参与求解，而执行为控制决策提供依据的计算。他们的典型任务包括估算可能取得的进展以及知识源的计算开销。他们的计算结果为控制数据，也被写到黑板上。

- 类
  - 控制
- 职责
  - 监视黑板
  - 安排知识源激活
- 协作者
  - 黑板
  - 知识源

从理论上说，黑板可能处于任何知识源都不适用的状态。在这种情况下，系统将无法提供结果。实际上，更可能出现的情形是，每个推理步骤都提出了多个新推测，导致接下来可采取的步骤猛增。因此，要解决的问题是限制备选方案的数量，而不是找到适用的知识源。

控制组件中有一个特殊的知识源或过程，它负责决定系统在什么情况下该停止以及最终结果是什么样的。在找到可接受的解或者系统的时间或空间资源已经耗尽时，系统将停止。

#### 动态

1. 控制组件的主循环启动。
2. 控制组件调用过程 nextSource()选择下一个知识源。
3. nextSource()首先查看黑板，判断哪些知识源可能会提供帮助。
4. nextSource()调用每个知识源的条件部分，知识源判断自己在当前状态下能否提供帮助以及如何提供帮助。
5. 控制组件选择要调用的知识源以及一个或一组要处理的推测。

#### 实现

1. 定义问题

- 确定问题域以及为找到解所需的知识领域。
- 仔细研究系统的输入，找出输入的所有特点。
- 定义系统的输出，确定为确保输出规范而可靠应满足的需求。
- 详细描述用户如何与系统交互。

2. 定义问题的解空间
   我们将解分为中间解和顶级解，还将其分为部分解和完整解。需要执行如下步骤

- 指出顶级解由哪些内容组成
- 列出解的各种抽象层级
- 将解组织成一个或多个抽象层次结构
- 找出完整解中可独立处理的部分，如词组中的单词、图片或区域的各个部分

3. 将求解过程分为如下步骤：

- 定义如何将解转换为上一层级的解
- 描绘如何作出同一抽象层级的推测
- 详细说明如何从其他层级寻找证据，以证实作出的推测
- 指出可以利用什么样的知识将部分解空间排除在外

4. 根据子任务将知识划分为专业知识源。

5. 定义黑板的词表。
   细化最初的解空间和解抽象层级定义，找到解的一种表示方式，让所有知识源都能读写黑板，必要时提供在黑板和知识源内部表示之间进行转换的组件。

6. 规范系统的控制机制。
   我们的目标是找到解空间中可信度最高的顶级完整解。

   制定良好的控制策略是系统设计中最难的一项工作，常常要经历繁琐的流程，尝试多种机制和子策略。在这种情况下，Strategy 模式有助于方便地更换(甚至在运行阶段更换)控制策略。

   下述机制可以优化知识源评估，让控制策略更有效、性能更高。

   - 将黑板内容变化分为两类，一类可能新增一组适用的知识源，另一类不会。发生第二类变化时，控制组件不会再次调用所有知识源的条件部分，而直接选择一个知识源。
   - 将每个黑板内容变化类别与另一组可能适用的知识源关联起来。
   - 控制聚焦(focusing of control)。焦点要么包含接下来应处理的黑板上的部分结果，要么包含应优先考虑的知识源。
   - 创建一个队列，适用的知识源在其中等待执行。

   下面是一些可供控制策略使用的经验法则。

   - 排列适用知识源的优先顺序。
   - 优先考虑低层级或高层级的推测。
   - 优先考虑对应于问题较大部分的推测。
   - 岛屿驱动(island driving)。这种策略假设特定推测是合意的一部分，并将其视为一个"确定性岛屿"，从而优先激活处理该推测的知识源，这样就无序不断搜索优先级更高的替代推测了。

7. 实现知识源。
   根据控制组件的需求，将知识源划分为条件部分和行动部分。为确保知识源的独立性和可更换性，不要对其他知识源和控制组件做任何假设。
   对于同一个系统的不同知识源，可使用不同的技术来实现。例如，一个知识源可能是基于规则的系统，另一个可能使用神经网络，第三个可能使用一组传统函数。

#### 变种

- Production System(产生式系统)。
- Repository(仓库)。

#### 已知应用

- HEARSAY-II。20 世纪 70 年代推出的语音识别系统。
- HASP/SIAP。用于发现敌方潜艇。
- CRYSALIS。用于根据 X 射线衍射数据推断蛋白质分子的三维结构。
- TRICERO。用于监视飞行器的活动。
- SUS。Software Understanding System (软件理解系统)，旨在帮助理解软件及寻找可重用的资产，通过将模式库中的模式与被分析的系统进行比较，逐渐生成一副可供用户查看的"模式地图"(pattern map)。

#### 示例解答

此图为 HEARSAY-II 理解词组"Are any by Feigenbaum and Feldman?" 执行的步骤的简化版本。
![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_5.png)

#### 效果

- 优点
  - 可以试验。可以试验不同的算法、尝试不同的控制经验法则。
  - 有助于提高可修改性和可维护性。
  - 知识源可重用。
  - 可提高容错能力和健壮性。

* 缺点
  - 难以测试。结果常常不可重现。
  - 不保证提供满意的解。
  - 难以制定上好的控制策略。
  - 效率低。在没有确定算法的情况下，效率低下胜过无能为力。
  - 开发工作量大。大多数 Blackboard 系统都需要经过数年才能发展成熟。原因包括下面两个：问题领域不明确；为确定词表、控制策略和知识源，需要做大量的试错性编程工作。
  - 不支持并行性。

## 3. 分布式系统

单机多 CPU、计算机网络化，是量大硬件技术发展趋势。

分布式系统有如下优点：

- 经济实惠。相比于大型机性价比高。
- 性能和扩展性
- 固有的分布性
- 可靠性

然而相比集中式系统，分布式系统对软件的要求截然不同。

有三个分布式架构模式：Pipes and Filters、Microkernel、Broker，下面将介绍 Broker。

### Broker

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_6.png)
Broker 架构模式可用于设计这样的分布式软件系统，即包含通过远程服务调用交互的组件。一个中间人组件负责协调通信(如转发请求)以及传递结果和异常。

#### 示例

一个运行在广域网上的 CIS(City Inofomation System)，提供餐馆、酒店、历史遗址或公共交通方面的信息。

#### 背景

分布式异构系统，其中的组件彼此独立又相互协作。

#### 问题

使用 Broker 可平衡如下作用力：

- 组件能够通过位置透明的远程服务调用访问其他组件提供的服务；
- 能够在运行阶段更换、添加或删除组件；
- 对组件和服务的用户隐藏与系统和实现相关的细节。

#### 解决方案

引入一个中间人组件，以降低客户端和服务器之间的耦合度。服务器向中间人注册，让客户端能够通过方法接口访问其服务。客户端通过中间人发送请求，以访问服务器的功能。中间人的任务包括找到合适的服务器、将请求转发给服务器以及将结果和异常传回给客户端。

因为对开发人员隐藏了分布性，Broker 模式降低了分布式应用程序的复杂度。这是通过引入一种对象模型实现的，这种对象模型将分布式服务封装在对象中。因此，Broker 系统可以集成两种核心技术：分布式技术和对象技术。

#### 结构

Broker 模式包含 6 类组件：客户端、服务器、中间人(broker)、网桥(bridge)、客户端代理(client-side proxy)和服务器端代理

服务器(server)实现了一些对象，这些对象通过由操作和属性组成的接口暴露其功能。通过接口定义语言(IDL)或二进制标准来提供这些接口。服务器分为两类：

- 向众多应用领域提供通用服务的服务器
- 实现特定功能，供单个应用领域或任务使用的服务器

客户端(client)是这样的应用程序，即它至少访问一个服务器的服务。为调用远程服务，客户端将请求转发给中间人。请求执行完毕后，客户端将从中间人那里收到响应或异常。

- 类
  - 客户端
- 职责
  - 实现用户功能
  - 通过客户端代理向服务器发送请求
- 协作者
  - 客户端代理
  - 中间人

* 类
  - 服务器
* 职责
  - 实现服务
  - 想本地中间人注册
  - 通过服务端代理向客户端发送响应和异常
* 协作者
  - 服务器端代理
  - 中间人

中间人(broker)相当于信使，负责将来自客户端的请求传输给服务器以及将响应和异常传回客户端。中间人必须有办法根据唯一的系统标识符找到请求的接收方。中间人向客户端和服务器提供 API，包括用于注册服务器和调用服务器方法的 API。

- 类
  - 中间人
- 职责
  - 注册/注销服务器
  - 提供 API
  - 传输消息
  - 错误恢复
  - 通过网桥与其他中间人互操作
  - 查找服务器
- 协作者
  - 客户端
  - 服务器
  - 客户端代理
  - 服务器端代理
  - 网桥

* 类
  - 客户端代理
* 职责
  - 封装系统特定的功能
  - 在客户端和中间人之间居中调停
* 协作者
  - 客户端
  - 中间人

- 类
  - 服务器端代理
- 职责
  - 调用服务器的服务
  - 封装系统特定的功能
  - 在服务器和中间人之间居中调停
- 协作者
  - 服务器
  - 中间人

网桥(bridge)是可选组件，它在两个中间人互操作时隐藏实现细节。如果 Broker 系统运行在异构网络中，通过网络传输请求时，不同中间人必须能够独立于网络和操作系统进行通信。网桥封装了所有这些与系统相关的细节。

- 类
  - 网桥
- 职责
  - 封装网络特定的功能
  - 在本地中间人和远程中间人的网桥之间居中调停
- 协作者
  - 中间人
  - 网桥

#### 动态

- 情景 1 服务器向本地中间人组件注册
- 情景 2 客户端向本地服务器发送请求
- 情景 3 不同中间人通过网桥组件交互

#### 实现

1. 定义对象模型或使用现有模型。
2. 决定系统应提供什么样的组件互操作性。
3. 指定中间人组件应向客户端和服务器提供的 API。
4. 使用代理对象对客户端和服务器隐藏实现细节。
5. 设计中间人组件，这是与 3 和 4 同时进行的。
6. 开发 IDL 编译器。

#### 示例解答

无

#### 变种

Direct Communication Broker System。出于效率考虑，有时可能放松客户端只能通过本地中间人发送请求的限制。在这个变种中，客户端可直接与服务器通信。中间人将服务器提供的通信渠道告知客户端，这样客户端就能建立到服务器的直接链路。在这种系统中，代理接替中间人负责大多数通信任务。

Message Passing Broker System。这个变种适用于专注数据传输(而非实现远程调用的抽象)的系统。

Trader System。客户端请求通常被转发给一台唯一标识的服务器。在有些情况下，客户端的目标是将请求发送给服务而非服务器。此时，客户端代理使用服务标识符(而不是服务器标识符)来访问服务器的功能。同一个请求可能被转发给多个实现了所需服务的服务器。

Adapter Broker System。为提高灵活性，可再添加一层，以便对服务器隐藏中间人组件的接口。这个适配器是中间人的一部分，负责注册服务器以及与服务器交互。

Callback Broker System。在主动通信模型中，客户端发出请求，服务器执行请求。也可以使用被动模型(reactive model)。被动模型是事件驱动的，没有客户端和服务器之分。事件发生时，中间人调用这种组件的回调方法，即它通过注册指出自己将对这种事件作出响应。

#### 已知应用

- CORBA 对象管理组织(OMG)定义的 CORBA(通用对象请求代理架构)规范采用了 Broker 架构模式。

- Microsoft OLE 定义了一种暴露和访问服务器接口的二进制标准。

- 万维网(World Wide Web)

#### 效果

- 优点
  - 位置透明性
  - 组件的可修改性和可扩展性
  - 可移植性
  - 不同 Broker 系统之间的互操作性
  - 可重用性

* 缺点
  - 效率不高
  - 容错性差
  - 测试和调试困难

#### 参考

Forwarder-Receiver 模式相比 Broker 模式，实现起来更简单，但灵活性差一些。

Proxy 模式的一个远程(remote)变种。

Client-Dispatcher-Server 模式。

Mediator 设计模式，这种模式将对象之间的全互联拓扑变成星型拓扑。

## 4. 交互式系统

### Model-View-Controller

Model-View-Controller(MVC)架构模式将交互式应用程序划分为三种组件：包含核心功能和数据的模型(Model)、向用户显示信息的试图(View)以及处理用户输入的控制器(Controller)。视图和控制器一起组成用户界面，变更传播机制确保用户界面和模型一致。

#### 示例

一个用比例代表政治选举的简单信息系统。用户通过徒刑界面与系统交互，投票数据发生变化后，必须马上在所有显示结果中反映出来。

#### 背景

人机交互界面灵活的交互式应用程序。

#### 问题

作用力如下：

- 在不同的窗口(如柱状图和饼图)中，以不同的方式显示相同的信息
- 数据发生变化后，必须马上在应用程序的显示结果和行为中反映出来
- 可轻松修改用户界面，甚至在运行阶段都能修改
- 支持不同的外观标准，移植用户界面不影响应用程序核心的代码

#### 解决方案

模型组件封装了核心数据和功能，独立于输出的表示方式和输入行为。

视图组件向用户显示信息，并从模型中获取数据。同一个模型可以有多个不同的视图。

每个视图都有相关联的控制器组件。控制器接收输入，这通常是表示鼠标移动、单机鼠标按钮或键盘输入的事件。

#### 结构

模型组件包含应用程序的功能核心，它封装了合适的数据，并暴露了执行应用程序特定处理的过程，而控制器代表用户调用这些过程。模型还提供了用于访问其数据的函数，供视图组件获取要显示的数据。

变更传播机制在模型中维护了一个注册表，其中列出了依赖于模型的组件。所有视图及部分控制器都通过注册指出发生哪些变化时应通知它们。模型的状态发生变化时，将触发变更传播机制。变更传播机制是模型与视图和控制器联系的唯一渠道。

- 类
  - 模型
- 职责
  - 提供应用程序的功能核心
  - 注册依赖于它的视图和控制器
  - 数据发生变化后通知依赖于它的组件
- 协作者
  - 视图
  - 控制器

视图组件向用户显示信息。不同的视图以不同方式显示模型中的数据，每个视图都定义了一个更新过程，该过程由变更传播机制激活。更新过程被调用时，视图从模型获取要显示的最新数据，并显示到屏幕上。

控制器接收用户事件表示的用户输入。如何将这些事件传递给控制器取决于用户界面平台，事件被转换为向模型或相关联的视图发出的请求。

如果控制器的行为依赖于模型的状态，它将向变更传播机制注册，并实现一个更新过程。

- 类
  - 视图
- 职责
  - 创建并初始化相关联的控制器
  - 向用户显示信息
  - 实现更新过程
  - 从模型那里获取数据

* 类
  - 控制器
* 职责
  - 接收用事件表示的用户输入
  - 将事件转换为向模型(视图)发出的服务请求(显示请求)
  - 必要时实现更新过程
* 协作者
  - 视图
  - 模型

#### 动态

- 情景 1 用户输入导致模型发生变化，进而触发变更传播机制
- 情景 2 初始化 MVC 模式中的组件。这种代码通常不在模型、视图和控制器中，例如，可能位于主程序中。每次打开模型的视图都将以类似的方式初始化视图和控制器。

#### 实现

第 1 ～ 6 步是编写基于 MVC 的应用程序的基本步骤，第 7 ～ 10 步是可选的，可提高灵活性，适合用于打造高度灵活的应用程序或应用程序框架。

1. 将人机交互与核心功能分离
2. 实现变更传播机制。Observer 模式(这里叫 Publisher-Subscriber 设计模式)
3. 设计并实现视图
4. 设计并实现控制器
5. 设计并实现视图-控制器关系
6. 实现搭建 MVC 的代码
7. 动态地创建视图。
   如果应用程序允许动态地打开和关闭视图，最好提供一个负责对打开的视图进行管理的组件。该组件还可负责在最后一个视图关闭后终止应用程序。要实现这种管理组件，可使用 View Handler 设计模式。
8. "可插入式"控制器。通过将控制方面与视图分离，可将视图与不同的控制器组合。可以利用这种灵活性实现不同的运行模式(如供新用户和专家级用户使用的模式)。
9. 创建视图和控制器层次结构。
10. 进一步降低系统的依赖性

#### 变种

Document-View。这个变种没有将视图和控制器分离。Document-View 的文档组件和视图组件之间是松耦合的，让一个文档可以同时有多个同步的视图。

#### 已知应用

- Smalltalk
- MFC，Microsoft Foundation Class Library(基础类库)使用了 Document-View

#### 效果

- 优点
  - 一个模型可以有多个视图
  - 视图同步
  - "可插入的"视图和控制器
  - 可更换外观
  - 可开发框架
- 缺点
  - 更复杂
  - 更新可能过度频繁
  - 视图和控制器联系紧密
  - 视图和控制器与模型紧耦合
  - 视图的数据访问效率低下
  - 移植时必须修改视图和控制器
  - 使用较新的用户界面工具时难以遵循 MVC

#### 参考

Presentation-Abstraction-Control 模式采用不同的方法将系统的用户界面与功能核心分离，其抽象组件相当于 MVC 模型组件，表示组件将 MVC 视图和控制器组件合二为一，而控制器组件负责协调抽象组件和表示组件之间的通信。在 Presentation-Abstraction-Control 模式中，表示组件和抽象组件之间的交互不像 MVC 那样仅限于调用更新过程。

PS: 感觉 PAC 模式就像 MVVM 模式的功能。

### Presentation-Abstraction-Control 模式

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_7.png)
架构模式 Presentation-Abstraction-Control(PAC)定义了一种适用于交互式软件系统的结构——由相互协作的智能体组成的层次结构。每个智能体都负责应用程序功能的特定方面，并包含三个组件：表示组件、抽象组件和控制组件，这将智能体的人机交互方面功能能够核心和通信方面分离了。

#### 示例

一个用比例代表政治选举的简单信息系统。

#### 背景

利用智能体开发交互式应用程序。

- 智能体(agent)指的是信息处理组件，包含事件接收器、维护状态的数据结构和处理器(processor)，其中处理器负责处理到来的事件及更新状态，还可能触发新事件。

#### 问题

交互式系统常常可视为一组相互协作的智能体。可能的作用力如下：

- 智能体通常维护自己的状态的数据。为了完成整个应用程序面临的任务，各个智能体必须有效地协作。为此，它们需要一种交换数据、消息和事件的机制。
- 每个智能体的人机交互方面的大不相同，需要提供自己的用户界面。
- 系统随事件的推移不断发展变化，表示方面尤其如此。

#### 解决方案

将交互式应用程序设计成由 PAC 智能体组成的树形结构，其中包含一个顶层智能体、多个中间层智能体和数目众多的底层智能体。每个智能体负责应用程序的特定方面，并由三个组件组成：表示组件、抽象组件和控制组件。

表示组件提供了 PAC 智能体的可视化行为；抽象组件维护智能体的底层数据模型，并提供操作这些数据的功能；控制组件是表示组件和抽象组件之间的桥梁，并提供了让智能体能够与其他 PAC 智能体通信的功能。

顶层 PAC 智能体提供了系统的功能核心，其他大部分 PAC 智能体都依赖或操作这个核心。另外，顶层 PAC 智能体还包含不属于特定子任务的用户界面，如菜单栏、显示应用程序信息的对话框等。

底层 PAC 智能体表示用户可操作的独立语义概念，如电子表格和图表。底层智能体向用户呈现这些概念，并支持用户可对这些智能体执行所有操作，如缩放或移动图表。

中间层 PAC 智能体表示下一层智能体的组合或它们之间的关系，例如，中间层智能体可能维护相同数据的多个视图，如建筑 CAD 系统中的房屋平面图和外观图。

#### 结构

- 类
  - 顶层智能体
- 职责
  - 提供系统的功能核心
  - 控制 PAC 层次结构
- 协作者
  - 中间层智能体
  - 底层智能体

* 类
  - 中间层智能体
* 职责
  - 协调下一层 PAC 智能体
  - 将下一层 PAC 智能体组合成抽象程度更高的单元
* 协作者
  - 顶层智能体
  - 中间层智能体
  - 底层智能体

- 类
  - 底层智能体
- 职责
  - 提供软件的特定视图或系统服务，包括相关联的人机交互
- 协作者
  - 顶层智能体
  - 中间层智能体

#### 动态

- 情景 1 打开新的选举数据柱状图视图时。
- 情景 2 用户在电子表格输入新数据时。

#### 实现

1. 定义应用程序模型
2. 制定 PAC 层次结构的总体组织策略
3. 确定顶层 PAC 智能体
   在分析模型中，找出表示系统功能核心的部分，这主要是维护系统全局数据模型的组件以及直接操作这些数据的组件。另外，找出在整个应用程序中都通用的用户界面元素，如菜单栏及显示系统信息的对话框。这一步找到的所有组件都将是顶层智能体的一部分。
4. 确定底层 PAC 智能体。
   在分析模型中找出这样的组件：表示系统最小的独立单元，且用户可对其进行操作或查看。
5. 确定提供系统服务的底层 PAC 智能体。
6. 确定用于组合下一层 PAC 智能体的中间层 PAC 智能体。
7. 确定用于协调底层智能体的中间层 PAC 智能体。
8. 将核心功能与人机交互分离。
9. 提供外部接口。
10. 连接成层次结构

#### 变种

- PAC 智能体为主动对象

- PAC 智能体为进程

#### 已知应用

- 网络流量管理(Network Traffic Management)
- 移动机器人(Mobile Robot)

#### 效果

- 优点
  - 分离关注点
  - 支持修改和扩展
  - 支持多任务
- 缺点
  - 系统更复杂
    请务必仔细考虑设计的层级粒度，决定在什么情况下不再将智能体细化为更多的底层智能体。
  - 复杂的控制组件
  - 效率
    PAC 智能体之间的通信开销可能影响系统的效率。
- 适用性
  应用程序中不可分割的语义概念越小、这些语义概念的用户界面越相似，这个模式就越不适用。另一方面，如果不可分割的语义概念很大，且需要自己的人机交互，PAC 将提供一种易于维护和扩展的结构，并完全分离不同系统任务的关注点。

#### 参考

MVC 模式

## 5. 可适应系统

### Microkernel

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_8.png)
架构模式 Microkernel 适用于必须能够适应不断变化的需求的系统，他将最基本的功能核心与扩展的功能和随客户而异的部分分离。微核还充当插座，用于插入扩展及协调它们之间的协作。

#### 示例

一个新的台式机操作系统 Hydra，能够轻松的移植到相关的硬件平台，能够轻松的适应未来的发展。

#### 背景

使用依赖于相同核心功能的编程接口开发多个应用程序。

#### 问题

有些应用领域需要应对大量类似的标准和技术，例如操作系统和图形用户界面等应用程序平台。这种系统的使用寿命通常很长，有时达 10 年甚至更长。在此期间，新技术会出现，旧技术会改变。需关注下述作用力：

- 应用程序平台必须应对硬件和软件的持续发展
- 应用程序平台必须可移植、可扩展、可适应，这样才能轻松地集成新兴技术

这种应用程序平台还需要能运行既有标准编写的应用程序。为支持范围广泛的应用程序，需要应用程序平台底层功能的多个视图。例如，Hydra 被设计成能够运行为 Microsoft Windows 和 OS/2 Warp 等流行操作系统开发的应用程序。这带来如下作用力：

- 你所属领域的应用程序需要支持不同但类似的应用程序平台
- 多个应用程序可能以不同的方式使用相同的功能核心，这要求底层应用程序平台模拟既有标准。
- 将应用程序平台的功能核心分为一个组件和一系列服务，并确保这个组件占用的内存尽可能少，而服务占用的处理时间尽可能少。。

#### 解决方案

将应用程序平台的基本服务封装到微核组件中。微核包含让运行在不同进程中的其他组件能够互相通信的功能，它还负责维护系统级资源，如文件和进程。另外，它还提供了让其他组件能够访问其功能的接口。
外部服务器实现了底层微核的视图，它们使用微核通过接口暴露的机制来创建这种视图。每个外部服务器都是一个独立进程，该进程本身就是一个应用程序平台，因此可将 Microkernel 系统视为集成了其他应用程序平台的应用程序平台。
客户端使用微核提供的通信工具与外部服务器通信。

#### 结构

微核实现了不可分割的服务，我们将这些服务称之为机制。这些机制相当于根基，更复杂的功能(我们称之为策略，policy)建立在它们的基础上。

- 类
  - 微核
- 职责
  - 提供核心机制
  - 提供通信工具
  - 封装系统细节
  - 管理和控制资源
- 协作者
  - 内部服务器

* 类
  - 内部服务器
* 职责
  - 实现额外的服务
  - 封装一些系统细节
* 协作者
  - 微核

- 类
  - 外部服务器
- 职责
  - 向客户端提供编程接口
- 协作者
  - 微核

* 类
  - 客户端
* 职责
  - 表示应用程序
* 协作者
  - 适配器

- 类
  - 适配器
- 职责
  - 对客户端隐藏系统细节，如通信工具
  - 代表客户端调用外部服务器的方法
- 协作者
  - 外部服务器
  - 微核

# 第三章 设计模式

## 1. 导言

## 2. 结构分解模式

## 3. 工作组织模式

## 4. 访问控制

## 5. 管理模式

## 6. 通信模式

# 第四章 成例

## 1. 导言

## 2. 成例的用途

## 3. 成例与风格

## 4. 到哪里去寻找成例

# 第五章 模式系统

## 1. 模式系统是什么

## 2. 模式分类

## 3. 选择模式

## 4. 作为实现指南的模式系统

## 5. 模式系统的演化

## 6 总结

# 第六章 模式与软件架构

## 1. 导言

## 2. 软件架构中的模式

## 3. 软件架构支持技术

## 4. 软件架构的非功能特征

## 5. 总结

# 第七章 模式界

## 1. 起源

## 2. 领军人物及其成果

## 3. 模式界

# 第八章 模式的发展方向

## 1. 模式挖掘

## 2. 模式的组织和模式索引

## 3. 方法和工具

## 4. 算法、数据结构和模式

## 5. 模式的规范化

## 6. 结语

// TODO 按章节拆解
