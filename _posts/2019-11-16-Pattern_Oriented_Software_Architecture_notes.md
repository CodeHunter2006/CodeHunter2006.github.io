---
layout: post
title: "面向模式的软件架构 读书笔记"
date: 2019-11-22 23:00:00 +0800
tags:
---

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_1.png)
《Pattern-Oriented Software Architecture--Volume 1--A System of Pattern》中文版于 2013 年出版，被公认为是架构师的必读读物，与《设计模式》同被奉为经典。

// TODO 全文读后感

- 本书的知识体系发源于《设计模式》，但是又提高了一个层次，以更通用的视角总结模式。将模式分为三个层次：架构模式、设计模式和成例(方言)。介绍了常用的架构模式、成例，补充了《设计模式》中没有介绍但常用的一些模式。
- 模式有助于将复杂的代码抽象成可学习的内容，提高学习效率、提高沟通效率
- 模式的实现并不局限于特定的范式或语言(这正是我之前把 C++中使用的设计模式应用于 Javascript 时的感受)
- 以前只知道系统设计要按照分层结构(Layers)，现在知道这其实只是其中一种模式，只不过这种模式使用较广泛

# 第一章 模式

## 1. 模式是什么？

模式最早在建筑学中被使用，建筑师 Christopher Alexander: "简而言之，模式既是现实世界中的一件作品，又是如何及何时创作该作品的规则。"

- 建筑示例：
  - 人性需求：1.既想舒适地坐下来。2.又想光线充足的地方。
  - 设计模式：低矮的窗台 + 舒适的座椅
  - 解释：上面两种元素缺少一种，都会让人很不舒服，而组合在一起往往适合某个场景。

* 软件示例：
  - 软件需求：1.带人机界面的程序，对应的有底层数据。2.界面会经常变化、并且可能有多个界面描述同一数据。3.界面对数据会有操作，可以改变数据。
  - 设计模式：MVC 设计模式
  - 解释：MVC 三个层正好满足了需求，在界面变更时减少了代码变更。

**软件架构模式**描述了在特定设计情形下反复出现的设计问题，并提供了已得到充分证明的通用解决方案摘要。解决方案摘要描述模式的组件、组件的职责和关系，以及这些组件协作的方式。

## 2. 模式之所以为模式

- 模式三要素
  - 背景 引发设计问题的背景情况
  - 问题 在特定背景下反复出现的一系列作用力
  - 解决方案 平衡这些作用力的配置方式
    - 结构 组件和组件之间的关系
    - 行为 运行阶段的行为

## 3. 模式类型

模式的规模和抽象程度各异，我们将模式分为三类：

1. Architectural Patterns(架构模式)
   描绘基本的软件系统组织纲要，提供了一组预定义的子系统，指出了这些子系统的职责，也包含用于子系统间关系进行组织的规则和指南。
   - 例如：MVC 模式就是一个架构模式，指定了交互式软件系统的总体结构。
2. Design Patterns(设计模式)
   提供了对软件系统的子系统、组件或它们之间的关系进行改进的纲要，描绘了对彼此通信的组件进行组织的常见结构，可解决特定背景下的一般性设计问题。
   - 例如：Observer(观察者模式)，比架构模式小，可以独立于编程语言和编程范式(paradigm)，可以有效的改进子系统的协作。
3. Idiom(方言，译作成例)
   是一种低层(low-level)模式，针对的是特定的编程语言。成例阐述如何使用给定的语言的功能来实现组件或组件间关系的特定方面。
   - 例如：Counted Pointer 模式，可以用于 C++的引用计数智能指针。而其它很多语言如 Go 就不需要这样的模式。

## 4. 模式之间的关系

1. 改进，例如 MVC 模式就是由多个更小的 Observer 模式改进而来。
2. 变种，例如 Document-View 模式是 MVC 的变种，更适合文档的编辑，但通知也更局限于文档编辑。
3. 组合，例如 利用 Forwarder-Receiver + Proxy 实现 RPC。

## 5. 模式的描述

描述、记录模式的目的是让别人也理解新找到的模式，能够用相同的语言、词汇来讨论模式，对于没有接触过该模式的人可以通过描述尽快把握模式的精髓。描述模板如下：

1. Name(名称)
   模式的名称和摘要
2. Also Known As(别名)
   模式的其它名称——如果有的话
3. Example(示例)
   一个真实的示例，证明问题确实存在，对即将介绍的模式确实有需求。在整个模式的描述中，将通过这个示例来说明解决方案和实现。
4. Context(上下文/背景)
   模式可能适用的情形
5. Problem(问题)
   模式解决的问题，包括涉及的作用力
6. Solution(解决方案)
   模式背后的基本解决原则
7. Structure(静态结构)
   详细说明模式的结构，包括每个参与组件的 CRC 卡(Classes, Responsibilities, Collaborations，面向对象设计中对一个类的描述)以及一个 OMT 类图(也可以用 UML 类图)
8. Dynamics(动态行为)
   在一些情景下，描述了模式运行阶段的行为。可以用序列图表示
9. Implementation(实现)
   模式实现指南。这些指南并非不变的规则，应根据实际需求调整实现
10. Example Resolved(示例解答)
    在前面没有涉及，但对示例的解决至关重要的各个方面进行讨论
11. Variants(变种)
    简要地描述当前模式的变种或具体化(specialization)
12. Known Uses(已知应用)
    模式在既有系统中的应用
13. Consequences(结果)
    模式提供的优点及潜在的缺点
14. See Also(参考)
    列举其它一些模式，它们要么解决了类似的问题，要么有助于改进当前模式

## 6. 模式与软件架构

- 模式可以作为我们思维的组件，在设计系统时使用。相比继承、多态这种架构技术，模式更加具体。
- 为了有效的使用模式，要将模式组织成模式系统(pattern system)。这种关系组织方式比模式分类(pattern catalog)更加有效，指出了模式之间错综复杂的关系，有助于寻找适合解决问题的模式及其替代方案。
- **模式的实现并不局限于特定的范式或语言**，例如：既是不实用继承(面向对象范式)实现 Proxy，代码差别也很小；利用函数指针完全可以用 C 语言实现 Strategy 模式。

# 第二章 架构模式

## 2. 从混乱到有序

在需求没有明确或已部分明确的情况下，只按照需求应用领域的规则来切分模块、类是无助于解决问题的。一方面，最终的系统将包含大量与应用领域没有直接关系的组件；另一方面，我们要求系统不仅能正常运行，还要具备一些与应用程序功能没有直接关系的特质，如可移植性、易维护性、易理解性、稳定性(鲁棒性)等。我们将介绍三个以不同方式对系统进行粗略划分的架构模式：Layers、Pipes and Filters、Blackboard。

### Layers

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_2.png)
Layers 架构模式有助于将应用程序划分为多组子任务，其中每组子任务都位于特定抽象层。

#### 示例

网络协议的分层架构

#### 背景

需要分解的大型系统

#### 问题

需要设计一个系统，需要同时解决高层问题和低层问题，而且高层依赖于低层。通常指定了目标平台，高层任务与平台之间的关系并非显而易见，这重要是因为这些任务过于复杂，无法直接使用平台提供的服务来实现。需要平衡下述作用力：

- 以后修改源码不会波及整个系统，其影响限定在一个组件内，不会影响其它组件。
- 接口稳定，甚至遵守标准组织制定的标准。
- 系统的各个部分都可以更换。可使用其它实现替换组件，而不影响其它组件。
- 未来可能需要打造其它系统，这些系统与当前设计的系统面临着相同的低层次问题。
- 应将类似的职责编组，让系统更容易理解和维护。
- 根本没有所谓的标准组件粒度。
- 复杂度组件需要进一步分解。
- 跨越组件边界可能影响性能，例如，必须跨越多个组件边界传输大量数据时。
- 系统将由一个程序员团队打造，因此分工必须明确，在架构设计阶段这种需求常常被忽视。

#### 解决方案

- 笼统的看，解决方案极其简单：将系统划分成适当的层数，并将它们堆叠起来。从最低的抽象层开始，沿抽象阶梯往上走。第 i 层的请求，将转换为发给 i-1 层的请求，每层的所有组件都必须处于相同的抽象层级。每层的服务都实现了一种功能，以有意义的方式组合下一层的服务。另外，服务还可能依赖于同一层的其它服务。

#### 结构

这种结构类似洋葱，每层都将下面的层保护起来，禁止上面的层直接访问它们。

- 类
  - 第 i 层
- 职责
  - 提供 i+1 层使用的服务
  - 将子任务委托给 i - 1 层
- 协作者
  - 第 i - 1 层

#### 动态

- 自上而下的请求，往往需要再分解为更多的自上而下的请求
- 自下而上的通知，往往会合并或者不合并的向上传递
- 请求不一定要转发到所有层，如果在中间某层能够处理了就可以直接返回结果
- 有些层是缓存层，要保存数据，所以是有状态的；有些层是只做转发、无状态的，开发起来较简单
- 两个包含 N 层的栈相互通信，其中的栈被称为协议栈，这是通信协议中常见的情景

#### 实现

下面的步骤并不是必须顺序执行或必不可少的，要根据实际程序开发改变，往往是"悠悠球"式的设计过程。

1. 定义将任务划分到不同层的抽象准则。
2. 根据抽象准则确定抽象层级数。
3. 给每层命名并分派任务。
4. 规范服务。最重要的实现原则是相邻层界限分明，即任何组件都不跨越多层。在层之间共享模块有悖于严格分层的原则。将更多服务放在高层通常胜过放在低层，低层应尽量保持"苗条"，这就是"倒置的重用金字塔"。
5. 完善层次划分，反复执行 1~4 步。
6. 规范每层的接口。通常下层对上层来说是一个"黑盒"，只提供一个统一的接口(flat interface)。通常尽量采用"黑盒"而不是"白盒"或"灰盒"。可以利用 Facade 进行封装，如果实在需要知道下层内部结构，可以利用 Reflection 救场。
7. 确定隔层的内部结构。可以利用 Bridge 来提供多种实现、用 Strategy 动态的更换算法。
8. 规范相邻层之间的通信。通常采用推模型，具体推拉模型之后在 Pipes and Filters 介绍。
9. 将相邻层解耦。可以用 Reactor 和 Command 模式解耦。
10. 制定错误处理策略。对于分层架构，处理错误的时间和代码量都会特别高。处理错误时最好能在本层完成，如果非要向上抛出则一定要先转换为上层可以理解的出错信息，并且是比较笼统的错误信息。如果不这样做，上层就会因为不了解内部结构而感到莫名其妙。例如我们常见的"404"错误。

#### 示例解答

FTP 应用间通信的功能，实际上是 FTP->TCP->IP->以太网->物理连接->...->FTP 的方式传输的，也是分了 5 层(包含物理连接)。

#### 变种

Relaxed Layered System. 层间关系不那么严格，每层都能使用下面的所有服务。这会使得系统难以维护，常见于操作系统，变化不频繁、性能要求比可维护性要求更高。
Layering Through Inheritance. 常见于面向对象系统中。将低层实现为基类、高层通过继承的方式使用积累。优点是高层可以根据需要修改低层的服务；缺点是高层和低层紧密耦合，当低层修改后，所有代码需要重新编译。

#### 已知应用

- 虚拟机。JVM 就是一种低层平台。
- API。API 通常就是低层向高层提供的。
- 信息系统(IS)。通常包含四层，由上到下分别为：表示层、应用程序逻辑层、领域层、数据库层。
- WindowsNT，属于 Relaxed Layered System。

#### 效果

- 优点：

  - 隔层可重用
    最佳实践：抽象明确、黑盒模式、良好的文档
  - 支持标准化
  - 限制了依赖关系的范围
    提高可移植性、可测试性
  - 可更换性
    用 Adapter 模式可以更换实现；用 Bridge 模式可以通过指针动态更换实现；硬件接口更换不同设备

- 缺点：

  - 行为变化可能引发雪崩效应
    例如低层网络性能变差，为了适应，各层都要改
  - 效率低下
    分层结构由于层间的数据转换，通常比整体结构(对象海洋)效率更低
  - 不必要的工作
    如果低层服务做了高层未要求的多余或重复的工作，将对性能带来负面影响。例如用户态到内核态的切换，未必有检查的必要。
  - 难以确定正确的层次粒度

#### 参考

- Composite Message 是 Composite 模式的变种，以面向对象的方式在层间传输消息。
- Microkernel 架构可视为一种特殊的分层结构。

### Pipes and Filters

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_3.png)
Pipes and Filters 架构模式提供的结构适合用于处理数据流的系统。每个处理步骤都封装在一个过滤器组件中，数据通过相邻过滤器之间的管道传输。通过重组过滤器，可打造多个相关的系统族。

#### 示例

一个可移植的编译器。编译通常要经过下面步骤：词法分析、语法分析、语义分析、中间代码(AuLait Another Universal Language for Intermediate Translation)生成、可选的中间代码优化(针对不同后端)

#### 背景

处理数据流

#### 问题

系统必须对输入数据流进行处理或转换，以单个组件的方式实现这种系统不可行，原因有多个：系统必须由多名开发人员打造；整个系统要完成的任务分多个处理阶段；需求很可能发生变化。需考虑如下作用力：

- 以后可通过更换或重组处理步骤来改进系统，这甚至可以由用户完成
- 相比大型组件，在其他环境中重用小型处理步骤更容易
- 不相邻的处理步骤不共享信息
- 存在不同的输入数据源，如网络连接和提供温度的硬件传感器
- 最终结果能够以各种方式显示和存储
- 如果要求用户将中间结果存储到文件中，供以后进一步处理，将很容易出错
- 应避免同时执行多个处理步骤，如并行或半并行地执行这些步骤

对于事件驱动的交互式系统，就不能划分为一系列执行的阶段，不适用这种架构。

#### 解决方案

架构模式 Pipes and Filters 将系统面临的任务分为多个一次执行的处理步骤。这些步骤通过在系统中传输的数据相关联：一个步骤的输出是下一个步骤的输入。每个处理步骤都由过滤器组件实现。过滤器一边使用数据一边提供数据，而不是等到获得所有输入后才生成输出。这降低了延迟，实现了真正的并行处理。系统的输入由诸如文本文件等数据源提供，而输出进入数据接收器(data sink)，如文件、终端、动画程序等。数据源、过滤器、数据接收器通过管道依次相连，每条管道都在相邻处理步骤之间传输数据。由管道连接的过滤器序列成为处理流水线(processing pipeline)。

#### 结构

- 类
  - 过滤器
- 职责
  - 获取输入数据
  - 对输入数据进行处理
  - 提供输出数据
- 协作者
  - 管道

过滤器组件的三种功能：

- 充实
  通过计算和添加信息来充实数据
- 提炼
  通过浓缩或提取信息来提炼数据
- 转换
  通过改变表示方式来转换数据

过滤器操作可由多种事件触发：

- 下一个流水线元素从过滤器拉取输出
- 前一个流水线元素向过滤器推送输入
- 常见的情况是，过滤器不断地循环，从流水线上游拉取输入，并向下游推送输出

管道指的是过滤器之间、数据源和第一个过滤器之间、最后一个过滤器和数据接收器之间的连接。

- 类
  - 管道
- 职责
  - 传输数据
  - 缓冲数据
  - 同步相邻的主动过滤器
- 协作者

  - 数据源
  - 数据接收器
  - 过滤器

- 类
  - 数据源
- 职责
  - 向处理流水线提供输入
- 协作者

  - 管道

- 类
  - 数据接收器
- 职责
  - 使用输出
- 协作者
  - 管道

#### 动态

- 情景 1
  推式流水线，数据源首先采取行动。数据写入触发被动过滤器采取行动。
- 情景 2
  拉式流水线，控制流程始于数据接收器请求数据。
- 情景 3
  推——拉式流水线，数据源和数据接收器都是被动的。在这里，由第二个过滤器主动发起处理过程。
- 情景 4
  这是 Pipes and Filters 系统更复杂也更为典型的行为。所有过滤器都主动拉取数据、执行计算并推送数据，因此每个过滤器都运行在独立的控制线程中，如作为独立的进程运行。过滤器由它们之间的缓冲管道同步。该情景还表明，使用过滤器可并行地执行程序。

#### 实现

1. 将系统要完成的任务划分为一系列处理阶段，每个阶段都只依赖于前一个阶段的输出。
2. 定义沿管道传递的数据的格式。注意数据类型的传输效率，如用文本表示浮点型效率较低。必须定义输入末尾的方式，可以用\$、Ctrl-D、Ctrl-Z 等标记。
3. 确定如何实现每条管道连接。管道是先进先出缓冲区，可以利用操作系统提供的，也可以直接调用的方式。可以将过滤器实现为独立的线程，并将管道实现为让数据生产者和消费者同步的队列。
4. 设计并实现过滤器。
5. 设计错误处理机制。流水线出错后很难恢复，通常是重启解决。可以使用特殊标记来标记输入数据流，数据原封不动地传输，最终进入输出，在这个过程中出现故障何以在响应阶段重启。另一种方法是使用管道缓冲数据，在过滤器崩溃时用它来重启流水线。
6. 搭配处理流水线。

#### 示例解答

在编译器的实现中，我们采用了全局的符号表，每个过滤器都可以访问。

#### 变种

tee and join 流水线系统。修改过滤器的入口和出口只能有一个的规定，允许过滤器有多个入口和多个出口。将流水线搭建成有向图，甚至可以包含反馈回路。如 UNIX 中的过滤器程序 tee。

#### 已知应用

- UNIX shell 和众多过滤器程序使 Pipes and Filters 随 UNIX 得以风行。
- CMS Pipelines 是 IBM 大型机操作系统的一种扩展。
- LASSPTools 是一个支持数值分析和图形学的工具集。

#### 效果

- 优点：
  - 不需要中间件，但也可以使用。
  - 可更换过滤器。通常不能在运行阶段更换过滤器。
  - 可重组过滤器。如 UNIX 管道机制。
  - 可重用过滤器组件。
  - 可快速创建流水线原型。
  - 效率因并行处理得以提高。

* 缺点：
  - 共享状态信息的开销高昂或缺乏灵活性。
  - 通过并行处理提高效率的初衷常常成为泡影，原因如下：
    - 相比由单个过滤器执行所有计算，在过滤器之间传输数据的开销可能更高。使用网络连接过滤器时尤其如此。
    - 有些过滤器使用完所有输入后才生成输出，这要么是它执行的任务(如排序)使然，要么是设计不佳，例如在应用程序允许逐渐处理的情况下没有这样做。
    - 在只有一个处理器的计算机上，线程或进程切换上下文的开销大。
    - 通过管道同步过滤器而管道缓冲区很小时，频繁地开启和停止管道效率低下。
  - 数据转换开销。
  - 错误处理。错误处理是 Pipes and Filters 模式的阿喀琉斯之踵。如果用于关键任务系统，根本不可能重启流水线或对错误置若罔闻，应该考虑其他架构(如 Layers)来打造系统。

#### 参考

对于必须可靠运行的系统，Layers 模式更适合，更容易实现错误处理机制。而 Pipes and Filters 模式的重要特征——轻松地重组和重用组件，这是 Layers 模式不具有的。

### Blackboard

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_4.png)
Blackboard 架构模式对还未找到确定解决策略的问题很有帮助。在 Blackboard 模式中，多个专业子系统通过集思广议，获得可能的部分解或近似解。

PS：Blackboard 的执行过程看起来像是状态模式，寻找最优解的过程正好适用于 AI 类项目。

#### 示例

语音识别，需要跨领域完成功能。

#### 背景

未找到或找不到确定解决之道的不成熟领域。

#### 问题

没有可行而确定的解决方案将原始数据转换为高级数据结构(如图表或英语词组)。例如：视觉识别、图像识别、语音识别、监控等。这种问题具有如下特点：可分解成多个子问题，但每个子问题都属于不同的专业领域。要解决子问题，需要使用不同的表示法和范式。

上述有些领域的信息可能不可靠或不准确，且每个转换步骤都可能提供多个解。在这种情况下，通常能找到最优解，但也可能只有次优解，甚至无解。因此，如果要根据其结果作出重要决策，必须对结果进行验证。

作用力如下：

- 不可能在合理的时间内遍历整个解空间。
- 鉴于领域还不成熟，可能需要对同一个子任务尝试不同的算法。因此，各个模块应易于更换。
- 子问题的算法各不相同。例如，识别波形中语音片段的算法就与根据单词序列生成词组的算法毫无关系。
- 输入、中间结果和最终结果的表示方式各不相同，而不同算法是根据不同范式实现的。
- 一个算法通常使用另一个算法的结果。
- 涉及不可靠的数据和近似解。
- 算法的执行顺序不确定时还可能要求支持并行。应尽可能避免严格按照顺序执行的解决方案。

#### 解决方案

Blackboard 架构背后的理念是，一系列独立的程序携手合作，致力于处理同一个数据结构。每个程序善于解决整项任务的某一部分；所有程序同理合作，致力于找到解决之道。

#### 结构

对系统进行划分，使其包含一个黑板组件、一系列知识源以及一个控制组件。

**黑板**为中央数据存储区，解空间中的元素及控制数据都存储在这里。我们使用术语词表(vocabulary)表示可能出现在黑板上的所有数据元素。黑板提供了一个接口，让所有知识源都能够对其进行读写。

解空间中的所有元素都可能出现在黑板上。对于在问题解决过程中得到的解，如果它出现在黑板上，我们便称之为推测(hypothesis)或黑板项(blackboard entry)。遭到否决的推测将从黑板中删除。

每个**知识**源都是一个独立的子系统，解决整个问题的特定方面。这些知识源解决的子问题一起构成问题域。任何一个知识源都无力独自完成系统面临的任务，找到解的唯一途径是整合多个知识源的结果。

知识源通常运行在两个抽象层级。如果知识源实现的是正向推理，将把解转换为上一个层级的解；进行反向推理的知识源在下一个层级寻找证据，如果找不到证据，可能退回到上一层级的解。

- 类
  - 黑板
- 职责
  - 管理中央数据
- 协作者

* 类
  - 知识源
* 职责
  - 评估自己的适用性
  - 计算结果
  - 更新黑板
* 协作者
  - 黑板

每个知识源都负责判断自己在什么情况下可帮助找到解，因此知识源分为条件部分和行动部分。条件部分对求解过程的当前状态(写在黑板上)进行评估，以判断自己能否助一臂之力。行动部分生成结果，可能导致黑板的内容发生变化。

**控制组件**运行一个监视黑板内容变化的循环，并决定接下来采取什么措施。它根据知识运用策略决定激活哪个知识源，让它发起评估。这种策略的依据是黑板上的数据。

该策略可能依赖于控制知识源，这些特殊的知识源不直接参与求解，而执行为控制决策提供依据的计算。他们的典型任务包括估算可能取得的进展以及知识源的计算开销。他们的计算结果为控制数据，也被写到黑板上。

- 类
  - 控制
- 职责
  - 监视黑板
  - 安排知识源激活
- 协作者
  - 黑板
  - 知识源

从理论上说，黑板可能处于任何知识源都不适用的状态。在这种情况下，系统将无法提供结果。实际上，更可能出现的情形是，每个推理步骤都提出了多个新推测，导致接下来可采取的步骤猛增。因此，要解决的问题是限制备选方案的数量，而不是找到适用的知识源。

控制组件中有一个特殊的知识源或过程，它负责决定系统在什么情况下该停止以及最终结果是什么样的。在找到可接受的解或者系统的时间或空间资源已经耗尽时，系统将停止。

#### 动态

1. 控制组件的主循环启动。
2. 控制组件调用过程 nextSource()选择下一个知识源。
3. nextSource()首先查看黑板，判断哪些知识源可能会提供帮助。
4. nextSource()调用每个知识源的条件部分，知识源判断自己在当前状态下能否提供帮助以及如何提供帮助。
5. 控制组件选择要调用的知识源以及一个或一组要处理的推测。

#### 实现

1. 定义问题

- 确定问题域以及为找到解所需的知识领域。
- 仔细研究系统的输入，找出输入的所有特点。
- 定义系统的输出，确定为确保输出规范而可靠应满足的需求。
- 详细描述用户如何与系统交互。

2. 定义问题的解空间
   我们将解分为中间解和顶级解，还将其分为部分解和完整解。需要执行如下步骤

- 指出顶级解由哪些内容组成
- 列出解的各种抽象层级
- 将解组织成一个或多个抽象层次结构
- 找出完整解中可独立处理的部分，如词组中的单词、图片或区域的各个部分

3. 将求解过程分为如下步骤：

- 定义如何将解转换为上一层级的解
- 描绘如何作出同一抽象层级的推测
- 详细说明如何从其他层级寻找证据，以证实作出的推测
- 指出可以利用什么样的知识将部分解空间排除在外

4. 根据子任务将知识划分为专业知识源。

5. 定义黑板的词表。
   细化最初的解空间和解抽象层级定义，找到解的一种表示方式，让所有知识源都能读写黑板，必要时提供在黑板和知识源内部表示之间进行转换的组件。

6. 规范系统的控制机制。
   我们的目标是找到解空间中可信度最高的顶级完整解。

   制定良好的控制策略是系统设计中最难的一项工作，常常要经历繁琐的流程，尝试多种机制和子策略。在这种情况下，Strategy 模式有助于方便地更换(甚至在运行阶段更换)控制策略。

   下述机制可以优化知识源评估，让控制策略更有效、性能更高。

   - 将黑板内容变化分为两类，一类可能新增一组适用的知识源，另一类不会。发生第二类变化时，控制组件不会再次调用所有知识源的条件部分，而直接选择一个知识源。
   - 将每个黑板内容变化类别与另一组可能适用的知识源关联起来。
   - 控制聚焦(focusing of control)。焦点要么包含接下来应处理的黑板上的部分结果，要么包含应优先考虑的知识源。
   - 创建一个队列，适用的知识源在其中等待执行。

   下面是一些可供控制策略使用的经验法则。

   - 排列适用知识源的优先顺序。
   - 优先考虑低层级或高层级的推测。
   - 优先考虑对应于问题较大部分的推测。
   - 岛屿驱动(island driving)。这种策略假设特定推测是合意的一部分，并将其视为一个"确定性岛屿"，从而优先激活处理该推测的知识源，这样就无序不断搜索优先级更高的替代推测了。

7. 实现知识源。
   根据控制组件的需求，将知识源划分为条件部分和行动部分。为确保知识源的独立性和可更换性，不要对其他知识源和控制组件做任何假设。
   对于同一个系统的不同知识源，可使用不同的技术来实现。例如，一个知识源可能是基于规则的系统，另一个可能使用神经网络，第三个可能使用一组传统函数。

#### 变种

- Production System(产生式系统)。
- Repository(仓库)。

#### 已知应用

- HEARSAY-II。20 世纪 70 年代推出的语音识别系统。
- HASP/SIAP。用于发现敌方潜艇。
- CRYSALIS。用于根据 X 射线衍射数据推断蛋白质分子的三维结构。
- TRICERO。用于监视飞行器的活动。
- SUS。Software Understanding System (软件理解系统)，旨在帮助理解软件及寻找可重用的资产，通过将模式库中的模式与被分析的系统进行比较，逐渐生成一副可供用户查看的"模式地图"(pattern map)。

#### 示例解答

此图为 HEARSAY-II 理解词组"Are any by Feigenbaum and Feldman?" 执行的步骤的简化版本。
![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_5.png)

#### 效果

- 优点
  - 可以试验。可以试验不同的算法、尝试不同的控制经验法则。
  - 有助于提高可修改性和可维护性。
  - 知识源可重用。
  - 可提高容错能力和健壮性。

* 缺点
  - 难以测试。结果常常不可重现。
  - 不保证提供满意的解。
  - 难以制定上好的控制策略。
  - 效率低。在没有确定算法的情况下，效率低下胜过无能为力。
  - 开发工作量大。大多数 Blackboard 系统都需要经过数年才能发展成熟。原因包括下面两个：问题领域不明确；为确定词表、控制策略和知识源，需要做大量的试错性编程工作。
  - 不支持并行性。

## 3. 分布式系统

单机多 CPU、计算机网络化，是量大硬件技术发展趋势。

分布式系统有如下优点：

- 经济实惠。相比于大型机性价比高。
- 性能和扩展性
- 固有的分布性
- 可靠性

然而相比集中式系统，分布式系统对软件的要求截然不同。

有三个分布式架构模式：Pipes and Filters、Microkernel、Broker，下面将介绍 Broker。

### Broker

![Pattern](/assets/images/2019-11-16-Pattern_Oriented_Software_Architecture_notes_6.png)
Broker 架构模式可用于设计这样的分布式软件系统，即包含通过远程服务调用交互的组件。一个中间人组件负责协调通信(如转发请求)以及传递结果和异常。

#### 示例

一个运行在广域网上的 CIS(City Inofomation System)，提供餐馆、酒店、历史遗址或公共交通方面的信息。

#### 背景

分布式异构系统，其中的组件彼此独立又相互协作。

#### 问题

使用 Broker 可平衡如下作用力：

- 组件能够通过位置透明的远程服务调用访问其他组件提供的服务；
- 能够在运行阶段更换、添加或删除组件；
- 对组件和服务的用户隐藏与系统和实现相关的细节。

#### 解决方案

引入一个中间人组件，以降低客户端和服务器之间的耦合度。服务器向中间人注册，让客户端能够通过方法接口访问其服务。客户端通过中间人发送请求，以访问服务器的功能。中间人的任务包括找到合适的服务器、将请求转发给服务器以及将结果和异常传回给客户端。

因为对开发人员隐藏了分布性，Broker 模式降低了分布式应用程序的复杂度。这是通过引入一种对象模型实现的，这种对象模型将分布式服务封装在对象中。因此，Broker 系统可以集成两种核心技术：分布式技术和对象技术。

#### 结构

Broker 模式包含 6 类组件：客户端、服务器、中间人(broker)、网桥(bridge)、客户端代理(client-side proxy)和服务器端代理

服务器(server)实现了一些对象，这些对象通过由操作和属性组成的接口暴露其功能。通过接口定义语言(IDL)或二进制标准来提供这些接口。服务器分为两类：

- 向众多应用领域提供通用服务的服务器
- 实现特定功能，供单个应用领域或任务使用的服务器

客户端(client)是这样的应用程序，即它至少访问一个服务器的服务。为调用远程服务，客户端将请求转发给中间人。请求执行完毕后，客户端将从中间人那里收到响应或异常。

- 类
  - 客户端
- 职责
  - 实现用户功能
  - 通过客户端代理向服务器发送请求
- 协作者
  - 客户端代理
  - 中间人

* 类
  - 服务器
* 职责
  - 实现服务
  - 想本地中间人注册
  - 通过服务端代理向客户端发送响应和异常
* 协作者
  - 服务器端代理
  - 中间人

中间人(broker)相当于信使，负责将来自客户端的请求传输给服务器以及将响应和异常传回客户端。中间人必须有办法根据唯一的系统标识符找到请求的接收方。中间人向客户端和服务器提供 API，包括用于注册服务器和调用服务器方法的 API。

- 类
  - 中间人
- 职责
  - 注册/注销服务器
  - 提供 API
  - 传输消息
  - 错误恢复
  - 通过网桥与其他中间人互操作
  - 查找服务器
- 协作者
  - 客户端
  - 服务器
  - 客户端代理
  - 服务器端代理
  - 网桥

* 类
  - 客户端代理
* 职责
  - 封装系统特定的功能
  - 在客户端和中间人之间居中调停
* 协作者
  - 客户端
  - 中间人

- 类
  - 服务器端代理
- 职责
  - 调用服务器的服务
  - 封装系统特定的功能
  - 在服务器和中间人之间居中调停
- 协作者
  - 服务器
  - 中间人

网桥(bridge)是可选组件，它在两个中间人互操作时隐藏实现细节。如果 Broker 系统运行在异构网络中，通过网络传输请求时，不同中间人必须能够独立于网络和操作系统进行通信。网桥封装了所有这些与系统相关的细节。

- 类
  - 网桥
- 职责
  - 封装网络特定的功能
  - 在本地中间人和远程中间人的网桥之间居中调停
- 协作者
  - 中间人
  - 网桥

#### 动态

- 情景 1 服务器向本地中间人组件注册
- 情景 2 客户端向本地服务器发送请求
- 情景 3 不同中间人通过网桥组件交互

#### 实现

1. 定义对象模型或使用现有模型。
2. 决定系统应提供什么样的组件互操作性。
3. 指定中间人组件应向客户端和服务器提供的 API。
4. 使用代理对象对客户端和服务器隐藏实现细节。
5. 设计中间人组件，这是与 3 和 4 同时进行的。
6. 开发 IDL 编译器。

#### 示例解答

## 4. 交互式系统

## 5. 可适应系统

# 第三章 设计模式

## 1. 导言

## 2. 结构分解模式

## 3. 工作组织模式

## 4. 访问控制

## 5. 管理模式

## 6. 通信模式

# 第四章 成例

## 1. 导言

## 2. 成例的用途

## 3. 成例与风格

## 4. 到哪里去寻找成例

# 第五章 模式系统

## 1. 模式系统是什么

## 2. 模式分类

## 3. 选择模式

## 4. 作为实现指南的模式系统

## 5. 模式系统的演化

## 6 总结

# 第六章 模式与软件架构

## 1. 导言

## 2. 软件架构中的模式

## 3. 软件架构支持技术

## 4. 软件架构的非功能特征

## 5. 总结

# 第七章 模式界

## 1. 起源

## 2. 领军人物及其成果

## 3. 模式界

# 第八章 模式的发展方向

## 1. 模式挖掘

## 2. 模式的组织和模式索引

## 3. 方法和工具

## 4. 算法、数据结构和模式

## 5. 模式的规范化

## 6. 结语

// TODO 按章节拆解
